#!/bin/bash

# ==================================================
# VPS 流量控制台 V8.4 (IFB Shaping, Dual-Stack, Precise Shaping)
# - 精准限速：HTB class + (TBF -> fq_codel) 叶子队列，目标误差 <= 10%
# - 支持 TCP/UDP 端口扫描
# - 支持 IPv4/IPv6（flower 优先，IPv4 可回退 u32）
# - 入方向：ingress redirect -> IFB shaping（不丢包，避免“像断网”）
# - 新增：查看当前所有端口限速情况（出/入/双向）
# - Debian/Ubuntu 兼容性加强
# ==================================================

RED='\033[31m'
GREEN='\033[32m'
YELLOW='\033[33m'
BLUE='\033[36m'
PLAIN='\033[0m'

[[ $EUID -ne 0 ]] && echo -e "${RED}错误：请使用 root 用户运行！${PLAIN}" && exit 1

# ---- deps ----
for cmd in ip tc ss awk grep printf uname curl tar modprobe sed cut tr; do
  command -v "$cmd" >/dev/null 2>&1 || { echo -e "${RED}缺少命令: $cmd${PLAIN}"; exit 1; }
done

# ---- interface ----
INTERFACE=$(ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}')
[[ -z "$INTERFACE" ]] && echo -e "${RED}错误：无法自动识别网卡，请检查路由/网络。${PLAIN}" && exit 1

IFB_DEV="ifb0"

# ---- tc params ----
USER_QUANTUM=15000
ROOT_QUANTUM=200000

DEFAULT_MINOR_HEX="fffe"
DEFAULT_CLASSID="1:${DEFAULT_MINOR_HEX}"
DEFAULT_HANDLE="fffe:" # fq_codel on default

PORT_CLASS_OFFSET=4096          # port -> minor mapping offset
ROOT_RATE="10000mbit"           # effectively "unlimited"
DEFAULT_BURST="1m"              # HTB burst
TBF_LATENCY_MS=50               # TBF latency target
TBF_MIN_BURST_BYTES=32768       # burst too small causes jitter; keep >= 32KB

SELECTED_PORT=""

# ==================================================
# Utils
# ==================================================
is_number() { [[ "$1" =~ ^[0-9]+$ ]]; }

port_to_minor_dec() { echo $(( $1 + PORT_CLASS_OFFSET )); }
port_to_hex_minor() { printf '%x' "$(port_to_minor_dec "$1")"; }

hex_to_dec() { printf "%d" "0x$1"; }

# best-effort tc wrapper (avoid script hard crash)
tc_try() { tc "$@" >/dev/null 2>&1; return 0; }

# detect flower (best effort)
has_flower() {
  tc filter help 2>/dev/null | grep -qi flower
}

# ==================================================
# IFB / Ingress redirect
# ==================================================
ensure_ifb() {
  modprobe ifb >/dev/null 2>&1 || true

  if ! ip link show "$IFB_DEV" >/dev/null 2>&1; then
    ip link add "$IFB_DEV" type ifb >/dev/null 2>&1 || {
      echo -e "${RED}错误：创建 $IFB_DEV 失败（内核/模块/权限问题）。${PLAIN}"
      return 1
    }
  fi

  ip link set dev "$IFB_DEV" up >/dev/null 2>&1 || true
  return 0
}

ensure_ingress_redirect() {
  ensure_ifb || return 1

  # ingress qdisc on physical NIC
  if ! tc qdisc show dev "$INTERFACE" 2>/dev/null | grep -q "ffff:"; then
    tc_try qdisc add dev "$INTERFACE" handle ffff: ingress
  fi

  # IPv4 redirect (prio 1)
  if ! tc filter show dev "$INTERFACE" parent ffff: 2>/dev/null | grep -q "protocol ip.*mirred.*redirect.*$IFB_DEV"; then
    tc_try filter del dev "$INTERFACE" parent ffff: protocol ip prio 1
    tc filter add dev "$INTERFACE" parent ffff: protocol ip prio 1 u32 \
      match u32 0 0 action mirred egress redirect dev "$IFB_DEV" >/dev/null 2>&1 || {
        echo -e "${RED}错误：设置 IPv4 ingress redirect 失败。${PLAIN}"
        return 1
      }
  fi

  # IPv6 redirect (prio 2)
  if ! tc filter show dev "$INTERFACE" parent ffff: 2>/dev/null | grep -q "protocol ipv6.*mirred.*redirect.*$IFB_DEV"; then
    tc_try filter del dev "$INTERFACE" parent ffff: protocol ipv6 prio 2
    tc filter add dev "$INTERFACE" parent ffff: protocol ipv6 prio 2 u32 \
      match u32 0 0 action mirred egress redirect dev "$IFB_DEV" >/dev/null 2>&1 || {
        echo -e "${RED}错误：设置 IPv6 ingress redirect 失败。${PLAIN}"
        echo -e "${YELLOW}提示：若内核/tc 不支持该写法，你仍可用 IPv4；IPv6 可能绕过限速。${PLAIN}"
        # 不直接 return 1，避免把整套功能干掉（但会提示风险）
      }
  fi

  return 0
}

# ==================================================
# HTB Tree init (per device)
# ==================================================
init_htb_tree() {
  local dev="$1"

  if ! tc qdisc show dev "$dev" 2>/dev/null | grep -q "htb 1:"; then
    tc_try qdisc add dev "$dev" root handle 1: htb default "$DEFAULT_MINOR_HEX" r2q 10
  else
    tc_try qdisc replace dev "$dev" root handle 1: htb default "$DEFAULT_MINOR_HEX" r2q 10
  fi

  if ! tc class show dev "$dev" 2>/dev/null | grep -q "1:1 "; then
    tc_try class add dev "$dev" parent 1: classid 1:1 htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM"
  else
    tc_try class replace dev "$dev" parent 1: classid 1:1 htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM"
  fi

  if ! tc class show dev "$dev" 2>/dev/null | grep -q "${DEFAULT_CLASSID} "; then
    tc_try class add dev "$dev" parent 1:1 classid "$DEFAULT_CLASSID" htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM"
  else
    tc_try class replace dev "$dev" parent 1:1 classid "$DEFAULT_CLASSID" htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM"
  fi

  # default leaf qdisc: fq_codel
  tc_try qdisc replace dev "$dev" parent "$DEFAULT_CLASSID" handle "$DEFAULT_HANDLE" fq_codel
}

init_all_trees() {
  init_htb_tree "$INTERFACE" || true
  ensure_ingress_redirect || return 1
  init_htb_tree "$IFB_DEV" || true
  return 0
}

# ==================================================
# Precise leaf: TBF -> fq_codel
# ==================================================
# Make shaping more accurate: attach TBF as leaf to class, then fq_codel under TBF
attach_precise_leaf() {
  local dev="$1"
  local classid="$2"      # e.g., 1:10abc
  local handle_hex="$3"   # e.g., 10abc0
  local rate_kbit="$4"

  # tbf rate needs bytes burst. Choose burst based on rate.
  # A practical burst: ~20ms of traffic (rate_kbit -> bytes per 20ms)
  # bytes_per_sec = rate_kbit*1000/8
  # burst_20ms = bytes_per_sec*0.02 = rate_kbit*1000/8*0.02 = rate_kbit*2.5
  local burst_bytes=$(( rate_kbit * 25 / 10 ))
  [[ "$burst_bytes" -lt "$TBF_MIN_BURST_BYTES" ]] && burst_bytes="$TBF_MIN_BURST_BYTES"

  local latency="${TBF_LATENCY_MS}ms"
  local tbf_handle="${handle_hex}:"
  local inner_parent="${handle_hex}:1"

  # Remove any existing leaf qdisc chain on this classid
  tc_try qdisc del dev "$dev" parent "$classid"

  # Attach TBF
  tc qdisc add dev "$dev" parent "$classid" handle "$tbf_handle" tbf \
    rate "${rate_kbit}kbit" burst "${burst_bytes}" latency "$latency" >/dev/null 2>&1 || {
      # fallback: fq_codel only (still works but less precise)
      tc_try qdisc replace dev "$dev" parent "$classid" handle "${handle_hex}f:" fq_codel
      echo -e "${YELLOW}警告：$dev $classid TBF 创建失败，已回退为 fq_codel（精度可能下降）。${PLAIN}"
      return 0
    }

  # Attach fq_codel under TBF
  tc_try qdisc replace dev "$dev" parent "$inner_parent" handle "${handle_hex}f:" fq_codel
}

# ==================================================
# Filters: flower preferred, IPv4 fallback u32, IPv6 requires flower (warn if not)
# ==================================================
del_prio_filters() {
  local dev="$1"
  local parent="$2"
  local prio="$3"
  tc_try filter del dev "$dev" parent "$parent" protocol ip prio "$prio"
  tc_try filter del dev "$dev" parent "$parent" protocol ipv6 prio "$prio"
}

add_filter_one() {
  local dev="$1" parent="$2" proto="$3" prio="$4" l4="$5" dir="$6" port="$7" flowid="$8"
  # flower attempt
  if has_flower; then
    if [[ "$dir" == "out" ]]; then
      tc filter add dev "$dev" parent "$parent" protocol "$proto" prio "$prio" flower \
        ip_proto "$l4" src_port "$port" flowid "$flowid" >/dev/null 2>&1 && return 0
    else
      tc filter add dev "$dev" parent "$parent" protocol "$proto" prio "$prio" flower \
        ip_proto "$l4" dst_port "$port" flowid "$flowid" >/dev/null 2>&1 && return 0
    fi
  fi

  # fallback u32 only for IPv4
  if [[ "$proto" == "ip" ]]; then
    if [[ "$dir" == "out" ]]; then
      if [[ "$l4" == "tcp" ]]; then
        tc filter add dev "$dev" parent "$parent" protocol ip prio "$prio" u32 \
          match ip protocol 6 0xff match ip sport "$port" 0xffff flowid "$flowid" >/dev/null 2>&1 && return 0
      else
        tc filter add dev "$dev" parent "$parent" protocol ip prio "$prio" u32 \
          match ip protocol 17 0xff match ip sport "$port" 0xffff flowid "$flowid" >/dev/null 2>&1 && return 0
      fi
    else
      if [[ "$l4" == "tcp" ]]; then
        tc filter add dev "$dev" parent "$parent" protocol ip prio "$prio" u32 \
          match ip protocol 6 0xff match ip dport "$port" 0xffff flowid "$flowid" >/dev/null 2>&1 && return 0
      else
        tc filter add dev "$dev" parent "$parent" protocol ip prio "$prio" u32 \
          match ip protocol 17 0xff match ip dport "$port" 0xffff flowid "$flowid" >/dev/null 2>&1 && return 0
      fi
    fi
  else
    # ipv6 without flower -> warn
    echo -e "${YELLOW}提示：当前 tc/内核可能不支持 flower，IPv6 端口匹配可能无法生效（IPv6 可能绕过限速）。${PLAIN}"
  fi

  return 1
}

add_filters_tcp_udp_dualstack() {
  local dev="$1" parent="$2" prio="$3" dir="$4" port="$5" flowid="$6"
  # delete first (both protocols)
  tc_try filter del dev "$dev" parent "$parent" protocol ip prio "$prio"
  tc_try filter del dev "$dev" parent "$parent" protocol ipv6 prio "$prio"

  # IPv4 TCP/UDP
  add_filter_one "$dev" "$parent" "ip"   "$prio" "tcp" "$dir" "$port" "$flowid" >/dev/null 2>&1 || true
  add_filter_one "$dev" "$parent" "ip"   "$prio" "udp" "$dir" "$port" "$flowid" >/dev/null 2>&1 || true
  # IPv6 TCP/UDP (flower preferred)
  add_filter_one "$dev" "$parent" "ipv6" "$prio" "tcp" "$dir" "$port" "$flowid" >/dev/null 2>&1 || true
  add_filter_one "$dev" "$parent" "ipv6" "$prio" "udp" "$dir" "$port" "$flowid" >/dev/null 2>&1 || true
}

# ==================================================
# Port selection & scan (TCP/UDP)
# ==================================================
function select_active_port() {
  echo -e "${YELLOW}[List] 正在扫描可操作端口(TCP/UDP)...${PLAIN}"
  echo -e "------------------------------------------------"
  printf "%-5s %-10s %-12s %-20s\n" "编号" "协议" "端口" "进程"
  echo -e "------------------------------------------------"

  declare -a port_list
  declare -a proto_list
  local index=1

  while read -r proto state localaddr _peer process; do
    if [[ "$proto" == "tcp" ]]; then
      [[ "$state" != "LISTEN" ]] && continue
      show_proto="TCP"; pcolor="${GREEN}"
    elif [[ "$proto" == "udp" ]]; then
      [[ "$state" != "UNCONN" ]] && continue
      show_proto="UDP"; pcolor="${BLUE}"
    else
      continue
    fi

    port=$(echo "$localaddr" | awk -F':' '{print $NF}')
    is_number "$port" || continue

    proc_name=$(echo "$process" | awk -F'"' '{print $2}')
    [[ -z "$proc_name" ]] && proc_name="-"

    port_list[$index]="$port"
    proto_list[$index]="$proto"
    printf "${pcolor}[%d]${PLAIN}   %-10s %-12s %-20s\n" "$index" "$show_proto" "$port" "$proc_name"
    ((index++))
  done < <(ss -H -tunlp 2>/dev/null | awk '{print $1, $2, $5, $6, $7}')

  echo -e "------------------------------------------------"
  echo -e "${GREEN}[m]${PLAIN}   手动输入端口号 (Manual Input)"
  echo -e "------------------------------------------------"

  read -p "请选择端口编号 (输入 m 手动填写): " select_idx

  if [[ "$select_idx" == "m" ]]; then
    read -p "请输入端口号: " input_port
    if ! is_number "$input_port"; then
      echo -e "${RED}错误：端口必须是数字！${PLAIN}"
      SELECTED_PORT=""
      return
    fi
    SELECTED_PORT="$input_port"
  elif [[ -n "${port_list[$select_idx]}" ]]; then
    SELECTED_PORT="${port_list[$select_idx]}"
    echo -e "${BLUE}你选择了端口: $SELECTED_PORT (${proto_list[$select_idx]^^})${PLAIN}"
  else
    echo -e "${RED}无效选择！${PLAIN}"
    SELECTED_PORT=""
  fi
}

function check_port_status() {
  clear
  echo -e "${YELLOW}[Scanning] 活跃端口深度扫描(TCP/UDP)...${PLAIN}"
  echo -e "----------------------------------------------------------------------"
  printf "%-10s %-12s %-15s %-15s %-20s\n" "协议" "端口" "状态" "活跃连接数" "进程名"
  echo -e "----------------------------------------------------------------------"

  while read -r proto state localaddr _peer process; do
    if [[ "$proto" == "tcp" ]]; then
      [[ "$state" != "LISTEN" ]] && continue
      ptag="TCP"; pcolor="${GREEN}"
      port=$(echo "$localaddr" | awk -F':' '{print $NF}'); is_number "$port" || continue
      conn=$(ss -H -tn state established 2>/dev/null | awk '{print $4}' | grep -w ":$port" | wc -l)
    elif [[ "$proto" == "udp" ]]; then
      [[ "$state" != "UNCONN" ]] && continue
      ptag="UDP"; pcolor="${BLUE}"
      port=$(echo "$localaddr" | awk -F':' '{print $NF}'); is_number "$port" || continue
      conn=$(ss -H -un 2>/dev/null | awk '{print $5,$6}' | awk -v p=":$port" '$1 ~ p && $2 !~ /\*:\*/ {c++} END{print c+0}')
    else
      continue
    fi

    proc=$(echo "$process" | awk -F'"' '{print $2}'); [[ -z "$proc" ]] && proc="-"
    if [[ "$conn" -gt 0 ]]; then conn_str="${conn} (Active)"; conn_color="${RED}"; else conn_str="0"; conn_color="${PLAIN}"; fi

    printf "${pcolor}%-10s${PLAIN} %-12s %-15s ${conn_color}%-15s${PLAIN} %-20s\n" \
      "$ptag" "$port" "Listening" "$conn_str" "$proc"
  done < <(ss -H -tunlp 2>/dev/null | awk '{print $1, $2, $5, $6, $7}')

  echo -e "----------------------------------------------------------------------"
}

# ==================================================
# Apply limits
# ==================================================
apply_port_limit() {
  echo -e "\n${BLUE}--- 配置端口限速（V8.4 精准模式）---${PLAIN}"

  select_active_port
  [[ -z "$SELECTED_PORT" ]] && return
  PORT=$SELECTED_PORT

  echo -e "\n请选择限制方向："
  echo -e "1. ${GREEN}下行${PLAIN} (Outbound / 用户下载：物理网卡 egress)"
  echo -e "2. ${GREEN}上行${PLAIN} (Inbound / 用户上传：IFB 入方向整形)"
  echo -e "3. ${YELLOW}双向${PLAIN} (同时限制)"
  read -p "请输入选项 [1-3]: " dir_choice

  case $dir_choice in
    1) direction="out" ;;
    2) direction="in" ;;
    3) direction="bi" ;;
    *) echo -e "${YELLOW}无效选项：默认双向${PLAIN}"; direction="bi" ;;
  esac

  read -p "请输入速率限制 (Mbps): " RATE_MBPS
  if ! is_number "$RATE_MBPS" || [[ "$RATE_MBPS" -le 0 ]]; then
    echo -e "${RED}错误：速率必须为正整数 Mbps${PLAIN}"
    return
  fi

  # Use decimal Mbps -> kbit; for closer accuracy, avoid rounding too early
  RATE_KBIT=$((RATE_MBPS * 1000))
  BURST="$DEFAULT_BURST"

  HEX_ID=$(port_to_hex_minor "$PORT")
  CLASSID="1:${HEX_ID}"
  HANDLE_HEX="${HEX_ID}0"         # for qdisc handles

  init_all_trees || { echo -e "${RED}初始化失败：IFB/redirect/HTB 未就绪。${PLAIN}"; return; }

  echo -e "${YELLOW}[Config] Port: $PORT  Rate: ${RATE_MBPS}Mbps  Class: $CLASSID${PLAIN}"

  # Outbound
  if [[ "$direction" == "out" || "$direction" == "bi" ]]; then
    del_prio_filters "$INTERFACE" "1:0" "$PORT"
    tc_try qdisc del dev "$INTERFACE" parent "$CLASSID"
    tc_try class del dev "$INTERFACE" parent 1:1 classid "$CLASSID"

    tc class add dev "$INTERFACE" parent 1:1 classid "$CLASSID" htb \
      rate "${RATE_KBIT}kbit" ceil "${RATE_KBIT}kbit" burst "$BURST" quantum "$USER_QUANTUM" >/dev/null 2>&1 || \
    tc class replace dev "$INTERFACE" parent 1:1 classid "$CLASSID" htb \
      rate "${RATE_KBIT}kbit" ceil "${RATE_KBIT}kbit" burst "$BURST" quantum "$USER_QUANTUM" >/dev/null 2>&1

    # precise leaf
    attach_precise_leaf "$INTERFACE" "$CLASSID" "$HANDLE_HEX" "$RATE_KBIT"

    # filters: dual-stack TCP/UDP
    add_filters_tcp_udp_dualstack "$INTERFACE" "1:0" "$PORT" "out" "$PORT" "$CLASSID"
  fi

  # Inbound (on IFB)
  if [[ "$direction" == "in" || "$direction" == "bi" ]]; then
    del_prio_filters "$IFB_DEV" "1:0" "$PORT"
    tc_try qdisc del dev "$IFB_DEV" parent "$CLASSID"
    tc_try class del dev "$IFB_DEV" parent 1:1 classid "$CLASSID"

    tc class add dev "$IFB_DEV" parent 1:1 classid "$CLASSID" htb \
      rate "${RATE_KBIT}kbit" ceil "${RATE_KBIT}kbit" burst "$BURST" quantum "$USER_QUANTUM" >/dev/null 2>&1 || \
    tc class replace dev "$IFB_DEV" parent 1:1 classid "$CLASSID" htb \
      rate "${RATE_KBIT}kbit" ceil "${RATE_KBIT}kbit" burst "$BURST" quantum "$USER_QUANTUM" >/dev/null 2>&1

    attach_precise_leaf "$IFB_DEV" "$CLASSID" "$HANDLE_HEX" "$RATE_KBIT"

    add_filters_tcp_udp_dualstack "$IFB_DEV" "1:0" "$PORT" "in" "$PORT" "$CLASSID"
  fi

  echo -e "${GREEN}[Success] 端口 $PORT 限速已生效（TBF 精准整形，目标误差 <=10%）。${PLAIN}"
  if ! has_flower; then
    echo -e "${YELLOW}提示：检测到 flower 可能不可用，IPv6 端口限速可能不完整；建议安装/启用支持 flower 的内核/iptables/tc。${PLAIN}"
  fi
}

apply_global_limit() {
  echo -e "\n${BLUE}--- 全局限速 (整机，出入均精准整形) ---${PLAIN}"
  read -p "请输入总速率 (Mbps): " RATE_MBPS
  if ! is_number "$RATE_MBPS" || [[ "$RATE_MBPS" -le 0 ]]; then
    echo -e "${RED}错误：速率必须为正整数 Mbps${PLAIN}"
    return
  fi

  RATE_KBIT=$((RATE_MBPS * 1000))
  BURST="$DEFAULT_BURST"

  init_all_trees || { echo -e "${RED}初始化失败：IFB/redirect/HTB 未就绪。${PLAIN}"; return; }

  # set default class rates
  tc_try class replace dev "$INTERFACE" parent 1:1 classid "$DEFAULT_CLASSID" htb \
    rate "${RATE_KBIT}kbit" ceil "${RATE_KBIT}kbit" burst "$BURST" quantum "$USER_QUANTUM"
  # default leaf keep fq_codel (global precision is less strict; if you want, you can convert default to TBF too)

  tc_try class replace dev "$IFB_DEV" parent 1:1 classid "$DEFAULT_CLASSID" htb \
    rate "${RATE_KBIT}kbit" ceil "${RATE_KBIT}kbit" burst "$BURST" quantum "$USER_QUANTUM"

  echo -e "${GREEN}[Success] 全局限速已生效（出入均 shaping）。${PLAIN}"
}

# ==================================================
# Show current limits (NEW)
# ==================================================
# Parse classes on device, list port-mapped classes and their rates
list_limits_on_dev() {
  local dev="$1"
  local label="$2"

  # Only show classes under parent 1:1 with classid 1:XXXX
  # Example line: class htb 1:10d3 parent 1:1 prio 0 rate 20000Kbit ceil 20000Kbit burst ...
  tc class show dev "$dev" 2>/dev/null | grep -E "class htb 1:" | while read -r line; do
    echo "$line" | grep -q "parent 1:1" || continue
    echo "$line" | grep -q "1:1 " && continue
    echo "$line" | grep -q "1:${DEFAULT_MINOR_HEX} " && continue

    classid=$(echo "$line" | awk '{print $3}')          # 1:10d3
    minor_hex=$(echo "$classid" | awk -F':' '{print $2}')
    rate_kbit=$(echo "$line" | sed -n 's/.* rate \([0-9]\+\)Kbit.*/\1/p')
    [[ -z "$rate_kbit" ]] && rate_kbit="?"

    # minor -> port
    minor_dec=$(hex_to_dec "$minor_hex" 2>/dev/null)
    port=$((minor_dec - PORT_CLASS_OFFSET))
    [[ "$port" -le 0 || "$port" -gt 65535 ]] && continue

    # Mbps display (keep 1 decimal)
    if [[ "$rate_kbit" != "?" ]]; then
      mbps_int=$((rate_kbit / 1000))
      mbps_dec=$(( (rate_kbit % 1000) / 100 ))
      rate_str="${mbps_int}.${mbps_dec} Mbps"
    else
      rate_str="?"
    fi

    printf "%-8s %-8s %-12s %-12s\n" "$label" "$port" "$classid" "$rate_str"
  done
}

show_current_limits() {
  clear
  echo -e "${BLUE}--- 当前端口限速清单（出/入/双向）---${PLAIN}"
  echo -e "说明：Outbound=物理网卡 egress；Inbound=IFB 入方向整形"
  echo -e "------------------------------------------------------------"
  printf "%-8s %-8s %-12s %-12s\n" "方向" "端口" "ClassID" "速率"
  echo -e "------------------------------------------------------------"

  # Build maps of port->rate for both directions so we can show BOTH nicely
  # We'll print per-device and let user interpret; simple and reliable.
  list_limits_on_dev "$INTERFACE" "Outbound"
  list_limits_on_dev "$IFB_DEV"   "Inbound"

  echo -e "------------------------------------------------------------"
  echo -e "${YELLOW}提示：如果某端口只出现在 Outbound 或 Inbound，说明当前只限制了单向。${PLAIN}"
  if ! has_flower; then
    echo -e "${YELLOW}提示：flower 可能不可用，IPv6 流量可能绕过端口分类；建议优先确保 flower 可用。${PLAIN}"
  fi
}

# ==================================================
# Remove
# ==================================================
remove_limit() {
  echo -e "\n1. 解除指定端口 (可区分方向)"
  echo -e "2. 重置所有限制 (网卡级 + IFB + redirect 清理)"
  read -p "选择: " sel

  if [[ "$sel" == "1" ]]; then
    select_active_port
    [[ -z "$SELECTED_PORT" ]] && return
    PORT=$SELECTED_PORT

    HEX_ID=$(port_to_hex_minor "$PORT")
    CLASSID="1:${HEX_ID}"

    echo -e "\n请选择要解除的方向："
    echo -e "1. 仅解除 ${GREEN}下行限制${PLAIN} (Outbound, 物理网卡)"
    echo -e "2. 仅解除 ${GREEN}上行限制${PLAIN} (Inbound, IFB)"
    echo -e "3. 解除 ${RED}双向限制${PLAIN} (Both)"
    read -p "输入选项 [1-3]: " rm_choice

    init_all_trees >/dev/null 2>&1 || true

    case $rm_choice in
      1)
        del_prio_filters "$INTERFACE" "1:0" "$PORT"
        tc_try qdisc del dev "$INTERFACE" parent "$CLASSID"
        tc_try class del dev "$INTERFACE" parent 1:1 classid "$CLASSID"
        echo -e "${GREEN}端口 $PORT [下行] 限制已移除。${PLAIN}"
        ;;
      2)
        del_prio_filters "$IFB_DEV" "1:0" "$PORT"
        tc_try qdisc del dev "$IFB_DEV" parent "$CLASSID"
        tc_try class del dev "$IFB_DEV" parent 1:1 classid "$CLASSID"
        echo -e "${GREEN}端口 $PORT [上行] 限制已移除。${PLAIN}"
        ;;
      *)
        del_prio_filters "$INTERFACE" "1:0" "$PORT"
        tc_try qdisc del dev "$INTERFACE" parent "$CLASSID"
        tc_try class del dev "$INTERFACE" parent 1:1 classid "$CLASSID"

        del_prio_filters "$IFB_DEV" "1:0" "$PORT"
        tc_try qdisc del dev "$IFB_DEV" parent "$CLASSID"
        tc_try class del dev "$IFB_DEV" parent 1:1 classid "$CLASSID"

        echo -e "${GREEN}端口 $PORT [双向] 限制已全部移除。${PLAIN}"
        ;;
    esac

    init_all_trees >/dev/null 2>&1 || true

  elif [[ "$sel" == "2" ]]; then
    tc_try qdisc del dev "$INTERFACE" root

    tc_try filter del dev "$INTERFACE" parent ffff: protocol ip prio 1
    tc_try filter del dev "$INTERFACE" parent ffff: protocol ipv6 prio 2
    tc_try qdisc del dev "$INTERFACE" ingress

    tc_try qdisc del dev "$IFB_DEV" root

    ip link set dev "$IFB_DEV" down >/dev/null 2>&1 || true
    ip link del "$IFB_DEV" >/dev/null 2>&1 || true

    echo -e "${GREEN}已重置：物理网卡 + IFB + redirect 全部清理完成。${PLAIN}"
  fi
}

# ==================================================
# Speedtest
# ==================================================
run_pro_speedtest() {
  echo -e "${YELLOW}[Testing] Speedtest...${PLAIN}"
  if [ ! -f "./speedtest" ]; then
    ARCH=$(uname -m)
    [[ "$ARCH" == "x86_64" ]] && URL="https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-x86_64.tgz"
    [[ "$ARCH" == "aarch64" ]] && URL="https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-aarch64.tgz"
    if [[ -z "$URL" ]]; then
      echo -e "${RED}不支持的架构: $ARCH${PLAIN}"
      return
    fi
    curl -sL "$URL" | tar xz speedtest && chmod +x speedtest
  fi
  ./speedtest --accept-license --accept-gdpr
}

# ==================================================
# Menu
# ==================================================
show_menu() {
  clear
  echo -e "=================================================="
  echo -e "       VPS 流量控制台 V8.4 (精准限速 + 清单查看)"
  echo -e "       物理网卡: ${GREEN}${INTERFACE}${PLAIN}"
  echo -e "       IFB 设备: ${GREEN}${IFB_DEV}${PLAIN}"
  echo -e "       默认类:   ${GREEN}${DEFAULT_CLASSID}${PLAIN}"
  echo -e "       flower:   $(has_flower && echo -e "${GREEN}OK${PLAIN}" || echo -e "${YELLOW}可能不可用${PLAIN}")"
  echo -e "=================================================="
  echo -e "1. 查看活跃端口 (状态监控)"
  echo -e "2. 设置 ${YELLOW}端口限速${PLAIN} (精准：TBF->fq_codel)"
  echo -e "3. 设置 ${RED}全局限速${PLAIN} (整机限制)"
  echo -e "4. 解除限制 / 重置 (含 IFB 清理)"
  echo -e "5. 运行测速 (Speedtest)"
  echo -e "6. 查看当前所有端口限速清单 ${GREEN}[NEW]${PLAIN}"
  echo -e "0. 退出"
  echo -e "=================================================="
  read -p "选择: " choice

  case $choice in
    1) check_port_status; read -p "回车返回..." ;;
    2) apply_port_limit; read -p "回车返回..." ;;
    3) apply_global_limit; read -p "回车返回..." ;;
    4) remove_limit; read -p "回车返回..." ;;
    5) run_pro_speedtest; read -p "回车返回..." ;;
    6) show_current_limits; read -p "回车返回..." ;;
    0) exit 0 ;;
    *) show_menu ;;
  esac
  show_menu
}

show_menu
