#!/bin/bash
# ==================================================
# VPS 流量控制台 V10.0 (3x-ui / Xray 专用稳态版)
# 核心策略：
# 1) 限“下载/出站”：按 xray 进程 UID 打 fwmark -> tc fw filter 精准限速（IPv4/IPv6）
# 2) 限“上传/入站”：IFB 入方向整形，按 dport(入站端口) 分类限速
# 3) 清单：持久化记录 + 可查看（不依赖解析 tc 输出）
# 4) Debian/Ubuntu 兼容：模块探测/加载；失败明确报错不假成功
#
# 依赖：iproute2(tc), nftables(推荐), ss
# ==================================================

set -u

RED='\033[31m'
GREEN='\033[32m'
YELLOW='\033[33m'
BLUE='\033[36m'
PLAIN='\033[0m'

[[ ${EUID:-999} -ne 0 ]] && echo -e "${RED}错误：请用 root 运行${PLAIN}" && exit 1

for cmd in ip tc ss awk sed grep cut tr uname date mkdir mv rm modprobe ps id; do
  command -v "$cmd" >/dev/null 2>&1 || { echo -e "${RED}缺少命令: $cmd${PLAIN}"; exit 1; }
done

# ----------------- 配置 -----------------
IFB_DEV="ifb0"
INTERFACE="$(ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}')"
[[ -z "$INTERFACE" ]] && echo -e "${RED}错误：无法识别主网卡（ip route get 8.8.8.8 失败）${PLAIN}" && exit 1

# HTB 基础
ROOT_RATE="10000mbit"
ROOT_QUANTUM=200000
USER_QUANTUM=15000
HTB_BURST="1m"

# 精准 TBF
TBF_LATENCY_MS=50
TBF_MIN_BURST_BYTES=32768

# classid 冲突规避
DEFAULT_MINOR_HEX="fffe"
DEFAULT_CLASSID="1:${DEFAULT_MINOR_HEX}"
PORT_CLASS_OFFSET=4096

# fwmark（给 xray 出站打标）
XRAY_MARK_HEX="0x1"
XRAY_MARK_DEC="1"

# 持久化清单
STATE_DIR="/var/lib/vps-tc"
DB_FILE="${STATE_DIR}/limits.db"
mkdir -p "$STATE_DIR" >/dev/null 2>&1 || true
touch "$DB_FILE" >/dev/null 2>&1 || true

# nftables 规则表
NFT_TABLE="vps_tc"
NFT_CHAIN="out_mark"

# ----------------- 工具函数 -----------------
is_number(){ [[ "$1" =~ ^[0-9]+$ ]]; }
try_modprobe(){ modprobe "$1" >/dev/null 2>&1 || true; }

has_nft(){ command -v nft >/dev/null 2>&1; }

port_to_hex_minor(){ printf '%x' $(( $1 + PORT_CLASS_OFFSET )); }

run_or_fail(){
  local msg="$1"; shift
  if ! "$@" >/dev/null 2>&1; then
    echo -e "${RED}[FAIL]${PLAIN} $msg"
    return 1
  fi
  return 0
}

# DB：type|key|dir|mbps|ts
db_upsert(){
  local type="$1" key="$2" dir="$3" mbps="$4"
  local ts; ts="$(date +%F_%T)"
  grep -vE "^${type}\|${key}\|" "$DB_FILE" > "${DB_FILE}.tmp" 2>/dev/null || true
  mv -f "${DB_FILE}.tmp" "$DB_FILE" >/dev/null 2>&1 || true
  echo "${type}|${key}|${dir}|${mbps}|${ts}" >> "$DB_FILE"
}
db_delete(){
  local type="$1" key="$2"
  grep -vE "^${type}\|${key}\|" "$DB_FILE" > "${DB_FILE}.tmp" 2>/dev/null || true
  mv -f "${DB_FILE}.tmp" "$DB_FILE" >/dev/null 2>&1 || true
}

# ----------------- 模块初始化（Debian/Ubuntu） -----------------
init_modules(){
  try_modprobe ifb
  try_modprobe sch_htb
  try_modprobe sch_tbf
  try_modprobe sch_fq_codel
  try_modprobe act_mirred
  try_modprobe cls_u32
  try_modprobe cls_fw
}

# ----------------- IFB / redirect（用于入方向整形） -----------------
ensure_ifb(){
  if ! ip link show "$IFB_DEV" >/dev/null 2>&1; then
    run_or_fail "创建 IFB($IFB_DEV) 失败（内核不支持 ifb 或权限问题）" ip link add "$IFB_DEV" type ifb || return 1
  fi
  ip link set dev "$IFB_DEV" up >/dev/null 2>&1 || true
  return 0
}

ensure_ingress_redirect(){
  ensure_ifb || return 1

  # ingress qdisc
  if ! tc qdisc show dev "$INTERFACE" 2>/dev/null | grep -q "ffff:"; then
    run_or_fail "创建 ingress qdisc 失败" tc qdisc add dev "$INTERFACE" handle ffff: ingress || return 1
  fi

  # IPv4 redirect
  if ! tc filter show dev "$INTERFACE" parent ffff: 2>/dev/null | grep -q "protocol ip.*mirred.*redirect.*${IFB_DEV}"; then
    tc filter del dev "$INTERFACE" parent ffff: protocol ip prio 1 >/dev/null 2>&1 || true
    run_or_fail "设置 IPv4 ingress redirect 失败" tc filter add dev "$INTERFACE" parent ffff: protocol ip prio 1 u32 \
      match u32 0 0 action mirred egress redirect dev "$IFB_DEV" || return 1
  fi

  # IPv6 redirect（尽力而为，不成功也提示风险）
  if ! tc filter show dev "$INTERFACE" parent ffff: 2>/dev/null | grep -q "protocol ipv6.*mirred.*redirect.*${IFB_DEV}"; then
    tc filter del dev "$INTERFACE" parent ffff: protocol ipv6 prio 2 >/dev/null 2>&1 || true
    tc filter add dev "$INTERFACE" parent ffff: protocol ipv6 prio 2 u32 \
      match u32 0 0 action mirred egress redirect dev "$IFB_DEV" >/dev/null 2>&1 || true
  fi

  return 0
}

# ----------------- HTB 树初始化（每个 dev 一棵） -----------------
ensure_htb_tree(){
  local dev="$1"

  if ! tc qdisc show dev "$dev" 2>/dev/null | grep -q "htb 1:"; then
    run_or_fail "在 $dev 创建 root HTB 失败" tc qdisc add dev "$dev" root handle 1: htb default "$DEFAULT_MINOR_HEX" r2q 10 || return 1
  else
    tc qdisc replace dev "$dev" root handle 1: htb default "$DEFAULT_MINOR_HEX" r2q 10 >/dev/null 2>&1 || true
  fi

  if ! tc class show dev "$dev" 2>/dev/null | grep -q "1:1 "; then
    run_or_fail "在 $dev 创建 class 1:1 失败" tc class add dev "$dev" parent 1: classid 1:1 htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" || return 1
  else
    tc class replace dev "$dev" parent 1: classid 1:1 htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" >/dev/null 2>&1 || true
  fi

  if ! tc class show dev "$dev" 2>/dev/null | grep -q "${DEFAULT_CLASSID} "; then
    run_or_fail "在 $dev 创建 default class 失败" tc class add dev "$dev" parent 1:1 classid "$DEFAULT_CLASSID" htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" || return 1
  else
    tc class replace dev "$dev" parent 1:1 classid "$DEFAULT_CLASSID" htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" >/dev/null 2>&1 || true
  fi

  tc qdisc replace dev "$dev" parent "$DEFAULT_CLASSID" handle fffe: fq_codel >/dev/null 2>&1 || true
  return 0
}

init_all(){
  init_modules
  ensure_htb_tree "$INTERFACE" || return 1
  ensure_ingress_redirect || return 1
  ensure_htb_tree "$IFB_DEV" || return 1
  return 0
}

# ----------------- 精准叶子：TBF -> fq_codel -----------------
attach_precise_leaf(){
  local dev="$1"
  local classid="$2"
  local handle_hex="$3"
  local rate_kbit="$4"

  local burst_bytes=$(( rate_kbit * 25 / 10 ))
  [[ "$burst_bytes" -lt "$TBF_MIN_BURST_BYTES" ]] && burst_bytes="$TBF_MIN_BURST_BYTES"
  local latency="${TBF_LATENCY_MS}ms"

  local tbf_handle="${handle_hex}:"
  local inner_parent="${handle_hex}:1"

  tc qdisc del dev "$dev" parent "$classid" >/dev/null 2>&1 || true

  run_or_fail "在 $dev/$classid 创建 TBF 失败" tc qdisc add dev "$dev" parent "$classid" handle "$tbf_handle" tbf \
    rate "${rate_kbit}kbit" burst "${burst_bytes}" latency "$latency" || return 1

  tc qdisc replace dev "$dev" parent "$inner_parent" handle "${handle_hex}f:" fq_codel >/dev/null 2>&1 || true
  return 0
}

# ==================================================
# A) 限 xray 出站：nft mark by UID -> tc fw filter
# ==================================================
detect_xray_uid(){
  # 常见：xray 用户 / nobody / root
  # 优先从进程拿到真实 uid
  local uid=""
  uid="$(ps -eo comm,uid 2>/dev/null | awk '$1=="xray"{print $2; exit}')"
  if [[ -z "$uid" ]]; then
    # 有些是 xray-linux-*
    uid="$(ps -eo comm,uid 2>/dev/null | awk '$1 ~ /^xray/ {print $2; exit}')"
  fi
  if [[ -z "$uid" ]]; then
    # fallback：存在用户 xray 就用它
    if id -u xray >/dev/null 2>&1; then uid="$(id -u xray)"; fi
  fi
  echo "$uid"
}

ensure_nft_mark_rule(){
  local uid="$1"
  if ! has_nft; then
    echo -e "${RED}[FAIL]${PLAIN} 系统没有 nft 命令。建议：apt install -y nftables"
    return 1
  fi

  # 建表/链（幂等）
  nft list table inet "$NFT_TABLE" >/dev/null 2>&1 || nft add table inet "$NFT_TABLE" >/dev/null 2>&1 || true

  # output hook mangle
  if ! nft list chain inet "$NFT_TABLE" "$NFT_CHAIN" >/dev/null 2>&1; then
    nft add chain inet "$NFT_TABLE" "$NFT_CHAIN" "{ type filter hook output priority mangle; policy accept; }" >/dev/null 2>&1 || true
  fi

  # 清掉旧规则（同 uid 标记）
  nft list chain inet "$NFT_TABLE" "$NFT_CHAIN" 2>/dev/null | grep -q "meta skuid ${uid} meta mark set ${XRAY_MARK_DEC}" && return 0

  # 添加规则：xray 进程发出的包打 mark=1（IPv4/IPv6 都会走 output）
  nft add rule inet "$NFT_TABLE" "$NFT_CHAIN" meta skuid "$uid" meta mark set "$XRAY_MARK_DEC" >/dev/null 2>&1 || {
    echo -e "${RED}[FAIL]${PLAIN} nft 添加 mark 规则失败（可能是内核不支持 meta skuid 或 nftables 未启用）"
    return 1
  }
  return 0
}

apply_xray_egress_limit(){
  echo -e "\n${BLUE}--- 限速：Xray 总出站（推荐，最稳）---${PLAIN}"

  local uid; uid="$(detect_xray_uid)"
  if [[ -z "$uid" ]]; then
    echo -e "${RED}[FAIL]${PLAIN} 未找到 xray 进程/用户。请确认 xray 在运行，或用户是否为 xray。"
    return
  fi
  echo -e "${YELLOW}检测到 xray UID: ${uid}${PLAIN}"

  read -p "请输入限速(Mbps): " mbps
  if ! is_number "$mbps" || [[ "$mbps" -le 0 ]]; then
    echo -e "${RED}错误：速率必须为正整数 Mbps${PLAIN}"
    return
  fi
  local rate_kbit=$((mbps * 1000))

  init_all || { echo -e "${RED}[FAIL]${PLAIN} 初始化 tc/ifb 失败"; return; }

  ensure_nft_mark_rule "$uid" || return

  # 给 xray 专用 class
  local classid="1:200"        # 固定 id，避免跟端口玩法冲突
  local handle_hex="2000"      # qdisc handle hex-ish，够用

  # 清旧
  tc filter del dev "$INTERFACE" parent 1:0 protocol all prio 10 >/dev/null 2>&1 || true
  tc qdisc  del dev "$INTERFACE" parent "$classid" >/dev/null 2>&1 || true
  tc class  del dev "$INTERFACE" parent 1:1 classid "$classid" >/dev/null 2>&1 || true

  run_or_fail "创建 xray egress class 失败" tc class add dev "$INTERFACE" parent 1:1 classid "$classid" htb \
    rate "${rate_kbit}kbit" ceil "${rate_kbit}kbit" burst "$HTB_BURST" quantum "$USER_QUANTUM" || return

  attach_precise_leaf "$INTERFACE" "$classid" "$handle_hex" "$rate_kbit" || return

  # fw filter：匹配 mark=1 的包 -> flowid 到 xray class
  # protocol all 覆盖 IPv4/IPv6
  run_or_fail "添加 fw filter 失败" tc filter add dev "$INTERFACE" parent 1:0 protocol all prio 10 handle "$XRAY_MARK_DEC" fw flowid "$classid" || return

  db_upsert "XRAY" "UID${uid}" "out" "$mbps"
  echo -e "${GREEN}[Success]${PLAIN} 已限制 xray 出站 ${mbps}Mbps（精准模式）。"
}

remove_xray_egress_limit(){
  local uid; uid="$(detect_xray_uid)"
  init_all >/dev/null 2>&1 || true

  tc filter del dev "$INTERFACE" parent 1:0 protocol all prio 10 >/dev/null 2>&1 || true
  tc qdisc  del dev "$INTERFACE" parent 1:200 >/dev/null 2>&1 || true
  tc class  del dev "$INTERFACE" parent 1:1 classid 1:200 >/dev/null 2>&1 || true

  if has_nft; then
    # 删除整个表更干净（只要你不在同表放别的规则）
    nft delete table inet "$NFT_TABLE" >/dev/null 2>&1 || true
  fi

  [[ -n "$uid" ]] && db_delete "XRAY" "UID${uid}"
  echo -e "${GREEN}已移除 xray 出站限速与 nft 标记规则${PLAIN}"
}

# ==================================================
# B) 限入站端口上传：IFB 上按 dport 分类
# ==================================================
select_port_manual(){
  read -p "请输入要限制的入站端口: " p
  if ! is_number "$p" || [[ "$p" -le 0 || "$p" -gt 65535 ]]; then
    echo -e "${RED}端口无效${PLAIN}"
    echo ""
    return
  fi
  echo "$p"
}

apply_inbound_port_limit(){
  echo -e "\n${BLUE}--- 限速：入站端口上传（IFB, 按 dport）---${PLAIN}"
  local port; port="$(select_port_manual)"
  [[ -z "$port" ]] && return

  read -p "请输入限速(Mbps): " mbps
  if ! is_number "$mbps" || [[ "$mbps" -le 0 ]]; then
    echo -e "${RED}错误：速率必须为正整数 Mbps${PLAIN}"
    return
  fi
  local rate_kbit=$((mbps * 1000))

  init_all || { echo -e "${RED}[FAIL]${PLAIN} 初始化 tc/ifb 失败"; return; }

  local hex_minor; hex_minor="$(port_to_hex_minor "$port")"
  local classid="1:${hex_minor}"
  local handle_hex="${hex_minor}0"

  # 清旧
  tc filter del dev "$IFB_DEV" parent 1:0 protocol ip   prio "$port" >/dev/null 2>&1 || true
  tc filter del dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$port" >/dev/null 2>&1 || true
  tc qdisc  del dev "$IFB_DEV" parent "$classid" >/dev/null 2>&1 || true
  tc class  del dev "$IFB_DEV" parent 1:1 classid "$classid" >/dev/null 2>&1 || true

  run_or_fail "创建 IFB 端口 class 失败" tc class add dev "$IFB_DEV" parent 1:1 classid "$classid" htb \
    rate "${rate_kbit}kbit" ceil "${rate_kbit}kbit" burst "$HTB_BURST" quantum "$USER_QUANTUM" || return

  attach_precise_leaf "$IFB_DEV" "$classid" "$handle_hex" "$rate_kbit" || return

  # IPv4：u32 够稳（dport 匹配）
  run_or_fail "添加 IPv4 dport filter 失败" tc filter add dev "$IFB_DEV" parent 1:0 protocol ip prio "$port" u32 \
    match ip dport "$port" 0xffff flowid "$classid" || return

  # IPv6：尽力而为（很多系统 u32 不好用），做不到就提示
  tc filter add dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$port" u32 \
    match u32 0 0 flowid "$classid" >/dev/null 2>&1 || true
  echo -e "${YELLOW}提示：IPv6 入站按 dport 精确匹配在不同内核/工具上差异大；若你客户端走 IPv6，建议优先关 v6 或升级 iproute2/内核。${PLAIN}"

  db_upsert "PORTIN" "${port}" "in" "$mbps"
  echo -e "${GREEN}[Success]${PLAIN} 已限制入站端口 ${port} 上传 ${mbps}Mbps（精准模式）。"
}

remove_inbound_port_limit(){
  local port; port="$(select_port_manual)"
  [[ -z "$port" ]] && return

  init_all >/dev/null 2>&1 || true

  local hex_minor; hex_minor="$(port_to_hex_minor "$port")"
  local classid="1:${hex_minor}"

  tc filter del dev "$IFB_DEV" parent 1:0 protocol ip prio "$port" >/dev/null 2>&1 || true
  tc filter del dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$port" >/dev/null 2>&1 || true
  tc qdisc  del dev "$IFB_DEV" parent "$classid" >/dev/null 2>&1 || true
  tc class  del dev "$IFB_DEV" parent 1:1 classid "$classid" >/dev/null 2>&1 || true

  db_delete "PORTIN" "${port}"
  echo -e "${GREEN}已移除入站端口 ${port} 上传限速${PLAIN}"
}

# ==================================================
# 清单查看（不靠 tc 输出猜，直接读 DB）
# ==================================================
show_limits(){
  clear
  echo -e "${BLUE}--- 当前限速清单（已记录）---${PLAIN}"
  echo -e "网卡: ${GREEN}${INTERFACE}${PLAIN} | IFB: ${GREEN}${IFB_DEV}${PLAIN}"
  echo -e "--------------------------------------------------------------"
  printf "%-8s %-12s %-6s %-8s %-20s\n" "类型" "对象" "方向" "速率" "时间"
  echo -e "--------------------------------------------------------------"

  if [[ ! -s "$DB_FILE" ]]; then
    echo -e "${YELLOW}(清单为空)${PLAIN}"
    return
  fi

  while IFS='|' read -r type key dir mbps ts; do
    printf "%-8s %-12s %-6s %-8s %-20s\n" "$type" "$key" "$dir" "${mbps}M" "$ts"
  done < "$DB_FILE"

  echo -e "--------------------------------------------------------------"
  echo -e "${YELLOW}建议：优先用 XRAY 出站限速（最稳）；入站上传再按端口补刀。${PLAIN}"
}

# ==================================================
# 监听端口查看（辅助）
# ==================================================
check_port_status(){
  clear
  echo -e "${YELLOW}[Scanning] 监听端口 (TCP/UDP)${PLAIN}"
  echo -e "---------------------------------------------"
  printf "%-6s %-8s %-20s\n" "协议" "端口" "进程"
  echo -e "---------------------------------------------"

  ss -H -tunlp 2>/dev/null | awk '{print $1,$2,$5,$7}' | while read -r proto state addr proc; do
    if [[ "$proto" == "tcp" && "$state" != "LISTEN" ]]; then continue; fi
    if [[ "$proto" == "udp" && "$state" != "UNCONN" ]]; then continue; fi
    [[ "$proto" != "tcp" && "$proto" != "udp" ]] && continue
    port="$(echo "$addr" | awk -F':' '{print $NF}')"
    is_number "$port" || continue
    pname="$(echo "$proc" | awk -F'"' '{print $2}')"
    [[ -z "$pname" ]] && pname="-"
    tag="TCP"; [[ "$proto" == "udp" ]] && tag="UDP"
    printf "%-6s %-8s %-20s\n" "$tag" "$port" "$pname"
  done

  echo -e "---------------------------------------------"
}

# ==================================================
# 重置全部
# ==================================================
reset_all(){
  tc qdisc del dev "$INTERFACE" root >/dev/null 2>&1 || true
  tc qdisc del dev "$INTERFACE" ingress >/dev/null 2>&1 || true
  tc qdisc del dev "$IFB_DEV" root >/dev/null 2>&1 || true
  ip link set dev "$IFB_DEV" down >/dev/null 2>&1 || true
  ip link del "$IFB_DEV" >/dev/null 2>&1 || true
  has_nft && nft delete table inet "$NFT_TABLE" >/dev/null 2>&1 || true
  : > "$DB_FILE" 2>/dev/null || true
  echo -e "${GREEN}已重置：tc/IFB/nft/清单 全部清理完成${PLAIN}"
}

# ==================================================
# 菜单
# ==================================================
show_menu(){
  clear
  echo -e "=================================================="
  echo -e "   VPS 流量控制台 V10.0（3x-ui / Xray 稳态版）"
  echo -e "   网卡: ${GREEN}${INTERFACE}${PLAIN} | IFB: ${GREEN}${IFB_DEV}${PLAIN}"
  echo -e "   nftables: $(has_nft && echo -e "${GREEN}OK${PLAIN}" || echo -e "${YELLOW}缺失(建议安装)${PLAIN}")"
  echo -e "=================================================="
  echo -e "1. 查看监听端口 (TCP/UDP)"
  echo -e "2. 限速：Xray 总出站（推荐，最稳）"
  echo -e "3. 限速：入站端口上传（IFB 按 dport）"
  echo -e "4. 查看当前限速清单"
  echo -e "5. 移除：Xray 出站限速"
  echo -e "6. 移除：入站端口上传限速"
  echo -e "7. 重置全部（慎用）"
  echo -e "0. 退出"
  echo -e "=================================================="
  read -p "选择: " c

  case "$c" in
    1) check_port_status; read -p "回车返回..." ;;
    2) apply_xray_egress_limit; read -p "回车返回..." ;;
    3) apply_inbound_port_limit; read -p "回车返回..." ;;
    4) show_limits; read -p "回车返回..." ;;
    5) remove_xray_egress_limit; read -p "回车返回..." ;;
    6) remove_inbound_port_limit; read -p "回车返回..." ;;
    7) reset_all; read -p "回车返回..." ;;
    0) exit 0 ;;
    *) show_menu ;;
  esac
  show_menu
}

show_menu
