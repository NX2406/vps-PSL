#!/bin/bash
# ==================================================

set -u

RED='\033[31m'
GREEN='\033[32m'
YELLOW='\033[33m'
BLUE='\033[36m'
CYAN='\033[96m'
PLAIN='\033[0m'

[[ ${EUID:-999} -ne 0 ]] && echo -e "${RED}错误：请使用 root 用户运行！${PLAIN}" && exit 1

# 检查基础命令
for cmd in ip tc ss awk sed grep cut tr uname date mkdir mv rm modprobe ps id curl head wc mktemp cat tar; do
  command -v "$cmd" >/dev/null 2>&1 || { echo -e "${RED}缺少命令: $cmd${PLAIN}"; exit 1; }
done

has_nft(){ command -v nft >/dev/null 2>&1; }
has_flower(){ tc filter help 2>/dev/null | grep -qi flower; }

INTERFACE="$(ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}')"
[[ -z "$INTERFACE" ]] && echo -e "${RED}错误：无法识别主网卡（ip route get 8.8.8.8 失败）${PLAIN}" && exit 1
IFB_DEV="ifb0"

# TC Params
ROOT_RATE="10000mbit"
ROOT_QUANTUM=200000
USER_QUANTUM=15000
HTB_BURST="1m"
TBF_LATENCY_MS=50
TBF_MIN_BURST_BYTES=32768

DEFAULT_MINOR_HEX="fffe"
DEFAULT_CLASSID="1:${DEFAULT_MINOR_HEX}"

# Xray Params
XRAY_MARK_DEC="1"
NFT_TABLE="vps_tc"
NFT_CHAIN="out_mark"
XRAY_OUT_CLASSID="1:200"
XRAY_IN_CLASSID="1:201"

# DB
STATE_DIR="/var/lib/vps-tc"
DB_FILE="${STATE_DIR}/limits.db"
mkdir -p "$STATE_DIR" >/dev/null 2>&1 || true
touch "$DB_FILE" >/dev/null 2>&1 || true

# ---------------- utils ----------------
is_number(){ [[ "$1" =~ ^[0-9]+$ ]]; }
try_modprobe(){ modprobe "$1" >/dev/null 2>&1 || true; }

run_or_fail(){
  local msg="$1"; shift
  local err
  err="$("$@" 2>&1 >/dev/null)" || {
    echo -e "${RED}[FAIL]${PLAIN} $msg"
    [[ -n "$err" ]] && echo -e "${YELLOW}输出:${PLAIN} $err"
    return 1
  }
  return 0
}

# DB Ops
db_upsert(){
  local type="$1" key="$2" dir="$3" mbps="$4" meta="$5"
  local ts; ts="$(date +%F_%T)"
  grep -vE "^${type}\|${key}\|${dir}\|" "$DB_FILE" > "${DB_FILE}.tmp" 2>/dev/null || true
  mv -f "${DB_FILE}.tmp" "$DB_FILE" >/dev/null 2>&1 || true
  echo "${type}|${key}|${dir}|${mbps}|${ts}|${meta}" >> "$DB_FILE"
}
db_delete_prefix(){
  local type="$1" key="$2"
  grep -vE "^${type}\|${key}\|" "$DB_FILE" > "${DB_FILE}.tmp" 2>/dev/null || true
  mv -f "${DB_FILE}.tmp" "$DB_FILE" >/dev/null 2>&1 || true
}

# ---------------- modules & init ----------------
init_modules(){
  try_modprobe ifb
  try_modprobe sch_htb
  try_modprobe sch_tbf
  try_modprobe sch_fq_codel
  try_modprobe act_mirred
  try_modprobe cls_u32
  try_modprobe cls_fw
  try_modprobe cls_flower
}

ensure_ifb(){
  if ! ip link show "$IFB_DEV" >/dev/null 2>&1; then
    run_or_fail "创建 IFB 失败" ip link add "$IFB_DEV" type ifb || return 1
  fi
  ip link set dev "$IFB_DEV" up >/dev/null 2>&1 || true
  return 0
}

ensure_ingress_redirect(){
  ensure_ifb || return 1
  if ! tc qdisc show dev "$INTERFACE" 2>/dev/null | grep -q "ffff:"; then
    run_or_fail "创建 ingress qdisc" tc qdisc add dev "$INTERFACE" handle ffff: ingress || return 1
  fi
  if ! tc filter show dev "$INTERFACE" parent ffff: 2>/dev/null | grep -q "protocol ip.*mirred.*redirect.*${IFB_DEV}"; then
    tc filter del dev "$INTERFACE" parent ffff: protocol ip prio 1 >/dev/null 2>&1 || true
    run_or_fail "IPv4 ingress redirect" tc filter add dev "$INTERFACE" parent ffff: protocol ip prio 1 u32 match u32 0 0 action mirred egress redirect dev "$IFB_DEV" || return 1
  fi
  if ! tc filter show dev "$INTERFACE" parent ffff: 2>/dev/null | grep -q "protocol ipv6.*mirred.*redirect.*${IFB_DEV}"; then
    tc filter del dev "$INTERFACE" parent ffff: protocol ipv6 prio 2 >/dev/null 2>&1 || true
    tc filter add dev "$INTERFACE" parent ffff: protocol ipv6 prio 2 u32 match u32 0 0 action mirred egress redirect dev "$IFB_DEV" >/dev/null 2>&1 || true
  fi
  return 0
}

ensure_htb_tree(){
  local dev="$1"
  if ! tc qdisc show dev "$dev" 2>/dev/null | grep -q "htb 1:"; then
    run_or_fail "Root HTB on $dev" tc qdisc add dev "$dev" root handle 1: htb default "$DEFAULT_MINOR_HEX" r2q 10 || return 1
  else
    tc qdisc replace dev "$dev" root handle 1: htb default "$DEFAULT_MINOR_HEX" r2q 10 >/dev/null 2>&1 || true
  fi
  if ! tc class show dev "$dev" 2>/dev/null | grep -q "1:1 "; then
    run_or_fail "Root Class 1:1" tc class add dev "$dev" parent 1: classid 1:1 htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" || return 1
  else
    tc class replace dev "$dev" parent 1:1 classid 1:1 htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" >/dev/null 2>&1 || true
  fi
  if ! tc class show dev "$dev" 2>/dev/null | grep -q "${DEFAULT_CLASSID} "; then
    run_or_fail "Default Class" tc class add dev "$dev" parent 1:1 classid "$DEFAULT_CLASSID" htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" || return 1
  else
    tc class replace dev "$dev" parent 1:1 classid "$DEFAULT_CLASSID" htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" >/dev/null 2>&1 || true
  fi
  tc qdisc replace dev "$dev" parent "$DEFAULT_CLASSID" handle fffe: fq_codel >/dev/null 2>&1 || true
  return 0
}

init_all(){
  init_modules
  ensure_htb_tree "$INTERFACE" || return 1
  ensure_ingress_redirect || return 1
  ensure_htb_tree "$IFB_DEV" || return 1
  return 0
}

attach_precise_leaf(){
  local dev="$1" classid="$2" handle_major_hex="$3" rate_kbit="$4"
  local burst_bytes=$(( rate_kbit * 25 / 10 ))
  [[ "$burst_bytes" -lt "$TBF_MIN_BURST_BYTES" ]] && burst_bytes="$TBF_MIN_BURST_BYTES"
  local latency="${TBF_LATENCY_MS}ms"
  local tbf_handle="${handle_major_hex}:"
  local inner_parent="${handle_major_hex}:1"

  tc qdisc del dev "$dev" parent "$classid" >/dev/null 2>&1 || true
  run_or_fail "Leaf TBF on $dev/$classid" tc qdisc add dev "$dev" parent "$classid" handle "$tbf_handle" tbf \
    rate "${rate_kbit}kbit" burst "${burst_bytes}" latency "$latency" || return 1
  tc qdisc replace dev "$dev" parent "$inner_parent" handle "${handle_major_hex}f:" fq_codel >/dev/null 2>&1 || true
  return 0
}

# ----------------- Allocation -----------------
minor_in_use(){ grep -E "minor=$1\s*$" "$DB_FILE" >/dev/null 2>&1; }
alloc_minor_for_port(){
  local port="$1"
  local start=$((1000 + (port % 50000)))
  local m="$start"; local tries=0
  while [[ "$tries" -lt 60000 ]]; do
    [[ "$m" -ge 65533 ]] && m=1000
    local hex; hex="$(printf '%x' "$m")"
    if ! minor_in_use "$hex"; then echo "$hex"; return 0; fi
    m=$((m+1)); tries=$((tries+1))
  done
  echo ""; return 1
}

# ----------------- 1) List Ports (Display Only) -----------------
list_active_ports(){
  echo -e "${YELLOW}[List] 扫描监听端口...${PLAIN}"
  echo -e "------------------------------------------------"
  printf "%-6s %-8s %-20s\n" "协议" "端口" "进程"
  echo -e "------------------------------------------------"
  while read -r proto state localaddr _peer process; do
    local tag="" color="$PLAIN"
    if [[ "$proto" == "tcp" && "$state" == "LISTEN" ]]; then tag="TCP"; color="$GREEN"
    elif [[ "$proto" == "udp" && "$state" == "UNCONN" ]]; then tag="UDP"; color="$BLUE"
    else continue; fi
    local port; port="$(echo "$localaddr" | awk -F':' '{print $NF}')"
    is_number "$port" || continue
    local pname; pname="$(echo "$process" | awk -F'"' '{print $2}')"
    [[ -z "$pname" ]] && pname="-"
    printf "${color}%-6s${PLAIN} %-8s %-20s\n" "$tag" "$port" "$pname"
  done < <(ss -H -tunlp 2>/dev/null | awk '{print $1, $2, $5, $6, $7}' | sort -k3 -t' ' -n)
  echo -e "------------------------------------------------"
}
menu_list_ports(){ clear; echo -e "${BLUE}--- 监听端口列表 ---${PLAIN}"; list_active_ports; }

# ----------------- 2) Xray Limits -----------------
detect_xray_uid_auto(){
  local uid
  uid="$(ps -eo comm,uid 2>/dev/null | awk '$1=="xray"{print $2; exit}')"
  [[ -z "$uid" ]] && uid="$(ps -eo comm,uid 2>/dev/null | awk '$1 ~ /^xray/ {print $2; exit}')"
  [[ -z "$uid" ]] && { id -u xray >/dev/null 2>&1 && uid="$(id -u xray)"; }
  echo "$uid"
}

ensure_nft_mark_rule(){
  local uid="$1"
  if ! has_nft; then echo -e "${RED}[FAIL]${PLAIN} 未安装 nftables"; return 1; fi
  nft list table inet "$NFT_TABLE" >/dev/null 2>&1 || nft add table inet "$NFT_TABLE" >/dev/null 2>&1 || true
  if ! nft list chain inet "$NFT_TABLE" "$NFT_CHAIN" >/dev/null 2>&1; then
    nft add chain inet "$NFT_TABLE" "$NFT_CHAIN" "{ type filter hook output priority mangle; policy accept; }" >/dev/null 2>&1 || true
  fi
  if nft list chain inet "$NFT_TABLE" "$NFT_CHAIN" 2>/dev/null | grep -q "meta skuid .* meta mark set ${XRAY_MARK_DEC}"; then
    return 0
  fi
  run_or_fail "nft add rule" nft add rule inet "$NFT_TABLE" "$NFT_CHAIN" meta skuid "$uid" meta mark set "$XRAY_MARK_DEC" || return 1
  return 0
}

apply_xray_out_limit(){
  local mbps="$1"
  local uid; uid="$(detect_xray_uid_auto)"
  if [[ -z "$uid" ]]; then
    echo -e "${YELLOW}警告：未能自动检测到 Xray 进程 UID。${PLAIN}"
    read -p "手动输入 UID (0取消): " input_uid
    if [[ -n "$input_uid" && "$input_uid" != "0" ]]; then uid="$input_uid"; else return 1; fi
  fi
  ensure_nft_mark_rule "$uid" || return 1

  local rate_kbit=$((mbps * 1000))
  local handle_hex="0200"

  tc filter del dev "$INTERFACE" parent 1:0 protocol all prio 10 >/dev/null 2>&1 || true
  tc qdisc  del dev "$INTERFACE" parent "$XRAY_OUT_CLASSID" >/dev/null 2>&1 || true
  tc class  del dev "$INTERFACE" parent 1:1 classid "$XRAY_OUT_CLASSID" >/dev/null 2>&1 || true

  run_or_fail "Class create" tc class add dev "$INTERFACE" parent 1:1 classid "$XRAY_OUT_CLASSID" htb rate "${rate_kbit}kbit" ceil "${rate_kbit}kbit" burst "$HTB_BURST" quantum "$USER_QUANTUM" || return 1
  attach_precise_leaf "$INTERFACE" "$XRAY_OUT_CLASSID" "$handle_hex" "$rate_kbit" || return 1
  run_or_fail "Filter add" tc filter add dev "$INTERFACE" parent 1:0 protocol all prio 10 handle "$XRAY_MARK_DEC" fw flowid "$XRAY_OUT_CLASSID" || return 1

  db_upsert "XRAY" "OUT" "out" "$mbps" "class=200,uid=$uid"
  echo -e "${GREEN}[Success]${PLAIN} Xray(UID:$uid) 总出站限制：${mbps} Mbps"
}

get_xray_listen_ports(){
  ss -H -tunlp 2>/dev/null | awk '$0 ~ /xray/ {print $1, $2, $5}' | while read -r proto state addr; do
    if [[ "$proto" == "tcp" && "$state" != "LISTEN" ]]; then continue; fi
    if [[ "$proto" == "udp" && "$state" != "UNCONN" ]]; then continue; fi
    port="$(echo "$addr" | awk -F':' '{print $NF}')"
    [[ "$port" =~ ^[0-9]+$ ]] && echo "$port"
  done | sort -n | uniq
}

apply_xray_in_limit(){
  local mbps="$1"
  local ports; ports="$(get_xray_listen_ports)"
  [[ -z "$ports" ]] && { echo -e "${RED}[FAIL]${PLAIN} 未检测到 xray 监听端口"; return 1; }

  local count; count="$(echo "$ports" | wc -l | tr -d ' ')"
  local rate_kbit=$((mbps * 1000))
  local handle_hex="0201"

  tc qdisc del dev "$IFB_DEV" parent "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
  tc class del dev "$IFB_DEV" parent 1:1 classid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true

  run_or_fail "Class create" tc class add dev "$IFB_DEV" parent 1:1 classid "$XRAY_IN_CLASSID" htb rate "${rate_kbit}kbit" ceil "${rate_kbit}kbit" burst "$HTB_BURST" quantum "$USER_QUANTUM" || return 1
  attach_precise_leaf "$IFB_DEV" "$XRAY_IN_CLASSID" "$handle_hex" "$rate_kbit" || return 1

  while read -r p; do
    [[ -z "$p" ]] && continue
    tc filter del dev "$IFB_DEV" parent 1:0 protocol ip prio "$p" >/dev/null 2>&1 || true
    tc filter add dev "$IFB_DEV" parent 1:0 protocol ip prio "$p" u32 match ip dport "$p" 0xffff flowid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
    tc filter del dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$p" >/dev/null 2>&1 || true
    if has_flower; then
      tc filter add dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$p" flower ip_proto tcp dst_port "$p" flowid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
      tc filter add dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$p" flower ip_proto udp dst_port "$p" flowid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
    fi
  done <<< "$ports"

  db_upsert "XRAY" "IN" "in" "$mbps" "class=201"
  echo -e "${GREEN}[Success]${PLAIN} Xray 总入站限制：${mbps} Mbps"
}

menu_set_xray_limits(){
  echo -e "\n${BLUE}--- 限制 Xray 速度 ---${PLAIN}"
  echo -e "1) 仅限制 出站\n2) 仅限制 入站\n3) 限制 入站+出站"
  read -p "选择: " sel
  read -p "输入速率(Mbps): " mbps
  [[ ! "$mbps" =~ ^[0-9]+$ ]] && echo -e "${RED}无效数字${PLAIN}" && return
  init_all || { echo -e "${RED}Init failed${PLAIN}"; return; }
  case "$sel" in
    1) apply_xray_out_limit "$mbps" ;;
    2) apply_xray_in_limit "$mbps" ;;
    3) apply_xray_out_limit "$mbps" && apply_xray_in_limit "$mbps" ;;
  esac
}

# ----------------- 3) Port Limits (Select Menu) -----------------
apply_port_limit_one(){
  local port="$1" dir="$2" mbps="$3"
  local rate_kbit=$((mbps * 1000))
  local minor_hex; minor_hex="$(alloc_minor_for_port "$port")"
  [[ -z "$minor_hex" ]] && { echo -e "${RED}ClassID 耗尽${PLAIN}"; return 1; }
  
  local classid="1:${minor_hex}"
  local handle_hex="$minor_hex"

  if [[ "$dir" == "out" ]]; then
    tc filter del dev "$INTERFACE" parent 1:0 protocol ip prio "$port" >/dev/null 2>&1 || true
    tc filter del dev "$INTERFACE" parent 1:0 protocol ipv6 prio "$port" >/dev/null 2>&1 || true
    tc class del dev "$INTERFACE" parent 1:1 classid "$classid" >/dev/null 2>&1 || true
    run_or_fail "Class create" tc class add dev "$INTERFACE" parent 1:1 classid "$classid" htb rate "${rate_kbit}kbit" ceil "${rate_kbit}kbit" burst "$HTB_BURST" quantum "$USER_QUANTUM" || return 1
    attach_precise_leaf "$INTERFACE" "$classid" "$handle_hex" "$rate_kbit" || return 1
    run_or_fail "Filter IPv4" tc filter add dev "$INTERFACE" parent 1:0 protocol ip prio "$port" u32 match ip protocol 6 0xff match ip sport "$port" 0xffff flowid "$classid" || return 1
    tc filter add dev "$INTERFACE" parent 1:0 protocol ip prio "$port" u32 match ip protocol 17 0xff match ip sport "$port" 0xffff flowid "$classid" >/dev/null 2>&1 || true
    if has_flower; then
      tc filter add dev "$INTERFACE" parent 1:0 protocol ipv6 prio "$port" flower ip_proto tcp src_port "$port" flowid "$classid" >/dev/null 2>&1 || true
      tc filter add dev "$INTERFACE" parent 1:0 protocol ipv6 prio "$port" flower ip_proto udp src_port "$port" flowid "$classid" >/dev/null 2>&1 || true
    fi
    db_upsert "PORT" "$port" "out" "$mbps" "minor=${minor_hex}"
    echo -e "${GREEN}[Success]${PLAIN} 端口 ${port} 出站限制：${mbps} Mbps"
    return 0
  fi

  if [[ "$dir" == "in" ]]; then
    tc filter del dev "$IFB_DEV" parent 1:0 protocol ip prio "$port" >/dev/null 2>&1 || true
    tc filter del dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$port" >/dev/null 2>&1 || true
    tc class del dev "$IFB_DEV" parent 1:1 classid "$classid" >/dev/null 2>&1 || true
    run_or_fail "Class create" tc class add dev "$IFB_DEV" parent 1:1 classid "$classid" htb rate "${rate_kbit}kbit" ceil "${rate_kbit}kbit" burst "$HTB_BURST" quantum "$USER_QUANTUM" || return 1
    attach_precise_leaf "$IFB_DEV" "$classid" "$handle_hex" "$rate_kbit" || return 1
    run_or_fail "Filter IPv4" tc filter add dev "$IFB_DEV" parent 1:0 protocol ip prio "$port" u32 match ip dport "$port" 0xffff flowid "$classid" || return 1
    if has_flower; then
      tc filter add dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$port" flower ip_proto tcp dst_port "$port" flowid "$classid" >/dev/null 2>&1 || true
      tc filter add dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$port" flower ip_proto udp dst_port "$port" flowid "$classid" >/dev/null 2>&1 || true
    fi
    db_upsert "PORT" "$port" "in" "$mbps" "minor=${minor_hex}"
    echo -e "${GREEN}[Success]${PLAIN} 端口 ${port} 入站限制：${mbps} Mbps"
    return 0
  fi
}

menu_port_limit(){
  echo -e "\n${BLUE}--- 特定端口限速 (支持序号点选) ---${PLAIN}"
  
  # 1. Gather data into arrays
  declare -a p_port p_proto p_name
  local idx=0
  
  local raw_data
  # 解析 ss: 协议, 本地地址, 进程. 按端口数字排序
  raw_data=$(ss -tunlp -H | awk '{
      proto=$1; addr=$5; proc=$7
      n=split(addr, a, ":"); port=a[n]
      split(proc, p, "\""); name=p[2]
      if (name == "") name="-"
      print port, proto, name
  }' | sort -k1,1n | uniq)

  # Header
  echo -e "----------------------------------------------------------------"
  printf "${GREEN}%-6s %-8s %-10s %-20s${PLAIN}\n" "序号" "协议" "端口" "进程"
  echo -e "----------------------------------------------------------------"

  if [[ -z "$raw_data" ]]; then
      echo -e "${YELLOW}未检测到活动端口${PLAIN}"
  else
      while read -r port proto name; do
          idx=$((idx+1))
          p_port[$idx]="$port"
          p_proto[$idx]="$proto"
          p_name[$idx]="$name"
          
          local color="$PLAIN"
          [[ "$proto" == "tcp" ]] && color="$GREEN"
          [[ "$proto" == "udp" ]] && color="$BLUE"
          
          printf "[%d]    ${color}%-8s${PLAIN} %-10s %-20s\n" "$idx" "${proto^^}" "$port" "$name"
      done <<< "$raw_data"
  fi

  echo -e "----------------------------------------------------------------"
  echo -e "${GREEN}[m]${PLAIN}    手动输入端口号"
  echo -e "----------------------------------------------------------------"

  read -p "请输入序号 或 m : " sel
  local target_port=""

  if [[ "$sel" == "m" ]]; then
      read -p "请输入端口号: " input_p
      target_port="$input_p"
  elif [[ "$sel" =~ ^[0-9]+$ ]] && [[ "$sel" -le "$idx" ]] && [[ "$sel" -gt 0 ]]; then
      target_port="${p_port[$sel]}"
      echo -e "已选择: 端口 ${GREEN}${target_port}${PLAIN} (${p_name[$sel]})"
  else
      echo -e "${RED}输入无效${PLAIN}"
      return
  fi

  if ! is_number "$target_port" || [[ "$target_port" -le 0 || "$target_port" -gt 65535 ]]; then 
      echo -e "${RED}端口无效: $target_port${PLAIN}"; return; 
  fi

  echo -e "\n1) 仅限制 出站/下行\n2) 仅限制 入站/上行\n3) 限制 入站+出站"
  read -p "选择: " sel
  read -p "速率(Mbps): " mbps
  [[ ! "$mbps" =~ ^[0-9]+$ ]] && echo -e "${RED}无效数字${PLAIN}" && return
  init_all || { echo -e "${RED}Init failed${PLAIN}"; return; }
  case "$sel" in
    1) apply_port_limit_one "$target_port" "out" "$mbps" ;;
    2) apply_port_limit_one "$target_port" "in"  "$mbps" ;;
    3) apply_port_limit_one "$target_port" "out" "$mbps" && apply_port_limit_one "$target_port" "in" "$mbps" ;;
  esac
}

# ----------------- 4) Port Limits (Remove) [ENHANCED] -----------------
remove_port_limit_exec(){
  local port="$1"
  local found=0
  if grep -qE "^PORT\|${port}\|" "$DB_FILE"; then found=1; fi
  if [[ "$found" -eq 0 ]]; then echo -e "${YELLOW}未找到端口 ${port} 的限速记录${PLAIN}"; return; fi

  # 1. Delete Filters
  tc filter del dev "$INTERFACE" parent 1:0 protocol ip prio "$port" >/dev/null 2>&1 || true
  tc filter del dev "$INTERFACE" parent 1:0 protocol ipv6 prio "$port" >/dev/null 2>&1 || true
  tc filter del dev "$IFB_DEV" parent 1:0 protocol ip prio "$port" >/dev/null 2>&1 || true
  tc filter del dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$port" >/dev/null 2>&1 || true

  # 2. Delete Classes
  while IFS='|' read -r type key dir mbps ts meta; do
    if [[ "$type" == "PORT" && "$key" == "$port" ]]; then
       local m; m="$(echo "$meta" | grep -o "minor=[0-9a-f]*" | cut -d= -f2)"
       if [[ -n "$m" ]]; then
         local classid="1:$m"
         if [[ "$dir" == "out" ]]; then
           tc qdisc del dev "$INTERFACE" parent "$classid" >/dev/null 2>&1 || true
           tc class del dev "$INTERFACE" parent 1:1 classid "$classid" >/dev/null 2>&1 || true
         elif [[ "$dir" == "in" ]]; then
           tc qdisc del dev "$IFB_DEV" parent "$classid" >/dev/null 2>&1 || true
           tc class del dev "$IFB_DEV" parent 1:1 classid "$classid" >/dev/null 2>&1 || true
         fi
       fi
    fi
  done < "$DB_FILE"

  # 3. Clean DB
  db_delete_prefix "PORT" "$port"
  echo -e "${GREEN}已移除端口 ${port} 的所有限速规则${PLAIN}"
}

menu_remove_port_limit(){
  echo -e "\n${BLUE}--- 移除 特定端口 限速 (支持序号点选) ---${PLAIN}"
  if [[ ! -s "$DB_FILE" ]] || ! grep -q "^PORT|" "$DB_FILE"; then
      echo -e "${YELLOW}(当前无端口限速记录)${PLAIN}"
      return
  fi

  echo -e "--------------------------------------------------------"
  printf "${GREEN}%-6s %-10s %-12s %-10s${PLAIN}\n" "序号" "端口" "方向" "限速"
  echo -e "--------------------------------------------------------"
  
  declare -a r_list_port
  local idx=0
  
  while IFS='|' read -r type port dir mbps ts meta; do
    if [[ "$type" == "PORT" ]]; then
        idx=$((idx+1))
        r_list_port[$idx]="$port"
        
        local d_str="未知"
        if [[ "$dir" == "out" ]]; then d_str="out(下行)"; fi
        if [[ "$dir" == "in" ]]; then d_str="in(上行)"; fi
        
        # 列表内容使用白色 (默认)
        printf "[%d]    %-10s %-12s %-10s\n" "$idx" "$port" "$d_str" "${mbps}Mbps"
    fi
  done < "$DB_FILE"
  echo -e "--------------------------------------------------------"

  echo -e "${GREEN}[输入]${PLAIN} 请输入序号(移除该条目端口的所有限制) 或 直接输入端口号:"
  read -p "选择: " input_val
  
  local target_port=""
  if [[ "$input_val" =~ ^[0-9]+$ ]] && [[ "$input_val" -le "$idx" ]] && [[ "$input_val" -gt 0 ]]; then
      target_port="${r_list_port[$input_val]}"
      # 如果输入的是序号，则从数组取值
      if [[ -z "$target_port" ]]; then target_port="$input_val"; fi
  else
      target_port="$input_val"
  fi

  if ! is_number "$target_port"; then echo -e "${RED}输入无效${PLAIN}"; return; fi
  
  echo -e "即将移除端口 ${GREEN}${target_port}${PLAIN} 的所有限速规则..."
  init_all >/dev/null 2>&1 || true
  remove_port_limit_exec "$target_port"
}

# ----------------- 5) Show List -----------------
show_limits(){
  clear
  echo -e "${BLUE}--- 当前限速清单 ---${PLAIN}"
  echo -e "网卡: ${GREEN}${INTERFACE}${PLAIN} | IFB: ${GREEN}${IFB_DEV}${PLAIN}"
  printf "%-8s %-8s %-6s %-8s %-20s\n" "类型" "对象" "方向" "速率" "备注"
  echo -e "--------------------------------------------------------"
  [[ ! -s "$DB_FILE" ]] && echo -e "${YELLOW}(空)${PLAIN}"
  while IFS='|' read -r type key dir mbps ts meta; do
    printf "%-8s %-8s %-6s %-8s %-20s\n" "$type" "$key" "$dir" "${mbps}M" "$meta"
  done < "$DB_FILE"
  echo -e "--------------------------------------------------------"
}

# ----------------- 6) Remove Xray Limits -----------------
menu_remove_xray_limits(){
  echo -e "\n${BLUE}--- 移除 Xray 限速 ---${PLAIN}"
  echo -e "1) 移除 出站\n2) 移除 入站\n3) 全部移除"
  read -p "选择: " sel
  init_all >/dev/null 2>&1 || true
  [[ "$sel" == "1" || "$sel" == "3" ]] && {
     tc filter del dev "$INTERFACE" parent 1:0 protocol all prio 10 >/dev/null 2>&1 || true
     tc qdisc  del dev "$INTERFACE" parent "$XRAY_OUT_CLASSID" >/dev/null 2>&1 || true
     tc class  del dev "$INTERFACE" parent 1:1 classid "$XRAY_OUT_CLASSID" >/dev/null 2>&1 || true
     has_nft && nft delete table inet "$NFT_TABLE" >/dev/null 2>&1 || true
     db_delete_prefix "XRAY" "OUT"
     echo -e "${GREEN}Xray 出站限制已移除${PLAIN}"
  }
  [[ "$sel" == "2" || "$sel" == "3" ]] && {
     tc qdisc del dev "$IFB_DEV" parent "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
     tc class del dev "$IFB_DEV" parent 1:1 classid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
     db_delete_prefix "XRAY" "IN"
     echo -e "${GREEN}Xray 入站限制已移除${PLAIN}"
  }
}

# ----------------- 7) Reset All -----------------
reset_all(){
  tc qdisc del dev "$INTERFACE" root >/dev/null 2>&1 || true
  tc qdisc del dev "$INTERFACE" ingress >/dev/null 2>&1 || true
  tc qdisc del dev "$IFB_DEV" root >/dev/null 2>&1 || true
  ip link set dev "$IFB_DEV" down >/dev/null 2>&1 || true
  ip link del dev "$IFB_DEV" >/dev/null 2>&1 || true
  has_nft && nft delete table inet "$NFT_TABLE" >/dev/null 2>&1 || true
  : > "$DB_FILE"
  echo -e "${GREEN}已重置所有 TC/NFT 规则${PLAIN}"
}

# ----------------- 8) Speedtest -----------------
install_ookla_speedtest(){
  echo -e "${YELLOW}检测到未安装 speedtest，正在安装...${PLAIN}"
  local installed=0
  if [ -f /etc/debian_version ]; then
    curl -s https://packagecloud.io/install/repositories/ookla/speedtest-cli/script.deb.sh | bash >/dev/null 2>&1
    apt-get update >/dev/null 2>&1 && apt-get install -y speedtest >/dev/null 2>&1 && installed=1
  elif [ -f /etc/redhat-release ]; then
    curl -s https://packagecloud.io/install/repositories/ookla/speedtest-cli/script.rpm.sh | bash >/dev/null 2>&1
    yum install -y speedtest >/dev/null 2>&1 && installed=1
  fi
  if [[ "$installed" -eq 0 ]]; then
    local arch; arch=$(uname -m)
    local url=""
    [[ "$arch" == "x86_64" ]] && url="https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-x86_64.tgz"
    [[ "$arch" == "aarch64" ]] && url="https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-aarch64.tgz"
    if [[ -n "$url" ]]; then
       local tmpdir; tmpdir=$(mktemp -d)
       curl -L -o "$tmpdir/speedtest.tgz" "$url"
       tar -xzf "$tmpdir/speedtest.tgz" -C "$tmpdir"
       [[ -f "$tmpdir/speedtest" ]] && mv "$tmpdir/speedtest" /usr/bin/speedtest && chmod +x /usr/bin/speedtest && installed=1
       rm -rf "$tmpdir"
    fi
  fi
  [[ "$installed" -eq 0 ]] && return 1
}

run_ookla_speedtest(){
  if ! command -v speedtest >/dev/null 2>&1; then install_ookla_speedtest || { echo -e "${RED}安装失败${PLAIN}"; return; }; fi
  echo -e "\n${BLUE}========== Speedtest by Ookla ==========${PLAIN}"
  read -p "Server ID (可选, 回车自动): " sid
  if [[ ! -f ~/.config/ookla/speedtest-cli.json ]]; then speedtest --accept-license --accept-gdpr >/dev/null 2>&1; fi
  if [[ -n "$sid" ]]; then speedtest --server-id="$sid" --progress=yes; else speedtest --progress=yes; fi
  echo -e "${BLUE}========================================${PLAIN}"
}

# ----------------- 9) Monitor -----------------
monitor_stats(){
  clear
  while true; do
    if command -v tput >/dev/null 2>&1; then tput cup 0 0; else clear; fi
    echo -e "${BLUE}=== 实时流量监控 [按回车返回] ===${PLAIN}"
    echo -e "刷新时间: $(date +%T)"
    echo -e "----------------------------------------------------"
    printf "%-6s %-6s %-4s %-8s %-10s %-8s\n" "TYPE" "PORT" "DIR" "LIMIT" "SENT" "DROP"
    echo -e "----------------------------------------------------"
    if [[ ! -s "$DB_FILE" ]]; then
      echo -e "${YELLOW}   (当前无限速规则)${PLAIN}"; echo ""; echo ""
    else
      while IFS='|' read -r type key dir mbps ts meta; do
         local dev="$INTERFACE"; local classid=""; local sent="-"; local dropped="0"
         if [[ "$type" == "XRAY" && "$dir" == "out" ]]; then classid="1:200"; fi
         if [[ "$type" == "XRAY" && "$dir" == "in" ]]; then dev="$IFB_DEV"; classid="1:201"; fi
         if [[ "$type" == "PORT" ]]; then
             local m; m="$(echo "$meta" | grep -o "minor=[0-9a-f]*" | cut -d= -f2)"
             [[ -n "$m" ]] && classid="1:$m"; [[ "$dir" == "in" ]] && dev="$IFB_DEV"
         fi
         if [[ -n "$classid" ]]; then
           local raw; raw="$(tc -s class show dev "$dev" classid "$classid" 2>/dev/null)"
           if [[ -n "$raw" ]]; then
             local bytes; bytes="$(echo "$raw" | grep -oP 'Sent \K[0-9]+' | head -1)"
             if [[ -n "$bytes" ]]; then
               if [[ "$bytes" -gt 1073741824 ]]; then sent="$(awk -v b="$bytes" 'BEGIN{printf "%.1fG", b/1073741824}')"
               elif [[ "$bytes" -gt 1048576 ]]; then sent="$(awk -v b="$bytes" 'BEGIN{printf "%.1fM", b/1048576}')"
               elif [[ "$bytes" -gt 1024 ]]; then sent="$(awk -v b="$bytes" 'BEGIN{printf "%.0fK", b/1024}')"
               else sent="${bytes}"; fi
             fi
             local drop; drop="$(echo "$raw" | grep -oP 'dropped \K[0-9]+' | head -1)"
             [[ -n "$drop" ]] && dropped="$drop"
           fi
         fi
         printf "%-6s %-6s %-4s %-8s %-10s " "$type" "$key" "$dir" "${mbps}M" "$sent"
         if [[ "$dropped" != "0" && "$dropped" != "-" ]]; then echo -e "${RED}${dropped}${PLAIN}"; else echo -e "${dropped}"; fi
      done < "$DB_FILE"
    fi
    echo -e "----------------------------------------------------"
    read -t 2 -n 1 -s -r; if [[ $? -eq 0 ]]; then break; fi
  done
}

# ----------------- 10) Uninstall -----------------
do_uninstall(){
  echo -e "${RED}警告：这将清除所有限速规则并删除脚本配置文件！${PLAIN}"
  read -p "确定要继续吗? (y/N): " confirm
  [[ "$confirm" != "y" ]] && return
  reset_all
  rm -rf "$STATE_DIR"
  echo -e "${GREEN}卸载完成。${PLAIN}"; echo -e "你可以手动删除此脚本: rm $0"; exit 0
}

# ----------------- Menu -----------------
show_menu(){
  clear
  echo -e "=================================================="
  echo -e "   VPS 流量控制台 V10.13 (Menu 4 Enhanced)"
  echo -e "   网卡: ${GREEN}${INTERFACE}${PLAIN} | IFB: ${GREEN}${IFB_DEV}${PLAIN}"
  echo -e "   nftables: $(has_nft && echo -e "${GREEN}OK${PLAIN}" || echo -e "${YELLOW}缺失${PLAIN}")"
  echo -e "=================================================="
  echo -e "1. 监听端口 (纯列表)"
  echo -e "2. 限制 Xray 速度 (Docker/UID)"
  echo -e "3. 限制 特定端口 速率 (序号点选)"
  echo -e "4. ${GREEN}移除 特定端口 限速${PLAIN} (支持序号)"
  echo -e "5. 查看限速清单"
  echo -e "6. 移除 Xray 限速"
  echo -e "7. 全部重置 (Reset)"
  echo -e "--------------------------------------------------"
  echo -e "8. Speedtest (Ookla 官方版)"
  echo -e "9. 实时流量监控 (Live Monitor)"
  echo -e "10. 彻底卸载与清理"
  echo -e "0. 退出"
  echo -e "=================================================="
  read -p "选择: " c

  case "$c" in
    1) menu_list_ports; read -p "回车返回..." ;;
    2) menu_set_xray_limits; read -p "回车返回..." ;;
    3) menu_port_limit; read -p "回车返回..." ;;
    4) menu_remove_port_limit; read -p "回车返回..." ;;
    5) show_limits; read -p "回车返回..." ;;
    6) menu_remove_xray_limits; read -p "回车返回..." ;;
    7) reset_all; read -p "回车返回..." ;;
    8) run_ookla_speedtest; read -p "回车返回..." ;;
    9) monitor_stats ;;
    10) do_uninstall ;;
    0) exit 0 ;;
    *) show_menu ;;
  esac
  show_menu
}

show_menu
