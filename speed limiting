#!/bin/bash
# ==================================================
# VPS 流量控制台 V10.22 (Zero-Latency Return)
#
# 功能全集：
# 1) 监听端口 (列表)
# 2) 限制 Xray 速度 (Docker/UID)
# 3) 限制 特定端口 速率 (序号点选)
# 4) 移除 特定端口 限速 (支持序号)
# 5) 查看限速清单
# 6) 移除 Xray 限速
# 7) 全部重置
# 8) Speedtest (国内+广电+国际)
# 9) 实时流量监控
# 10) 彻底卸载
#
# 修改记录 V10.22:
# - [修复] 子菜单输入 0 后立即返回主菜单，不再需要二次回车
# - [优化] 错误提示和操作成功提示的停留逻辑
#
# CentOS 7.9 修复点（不改变原功能/架构）：
# - CentOS7 常无 nftables：为“Xray 出站标记”增加 iptables(mangle+owner) 兜底
# - 菜单 nftables 状态：若无 nft 但可用 iptables，则显示 OK(iptables) 而不是 缺失
# - reset / 移除 Xray 限速时同步清理 iptables 规则
# - 依赖检查补充 iptables
# ==================================================

set -u

RED='\033[31m'
GREEN='\033[32m'
YELLOW='\033[33m'
BLUE='\033[36m'
CYAN='\033[96m'
PLAIN='\033[0m'

# 1. 权限与环境检查
[[ ${EUID:-999} -ne 0 ]] && echo -e "${RED}错误：请使用 root 用户运行！${PLAIN}" && exit 1

# ----------------- 依赖自动补齐（CentOS/RHEL/Debian 全系） -----------------
detect_pkg_mgr(){
  if command -v apt-get >/dev/null 2>&1; then echo "apt"; return; fi
  if command -v dnf >/dev/null 2>&1; then echo "dnf"; return; fi
  if command -v yum >/dev/null 2>&1; then echo "yum"; return; fi
  echo ""
}

install_pkgs(){
  local mgr="$1"; shift
  local pkgs=("$@")
  [[ "${#pkgs[@]}" -eq 0 ]] && return 0
  case "$mgr" in
    apt)
      DEBIAN_FRONTEND=noninteractive apt-get update -y >/dev/null 2>&1 || true
      DEBIAN_FRONTEND=noninteractive apt-get install -y "${pkgs[@]}" ;;
    dnf)
      dnf -y install "${pkgs[@]}" ;;
    yum)
      yum -y install "${pkgs[@]}" ;;
    *)
      return 1 ;;
  esac
}

ensure_deps(){
  local mgr; mgr="$(detect_pkg_mgr)"
  [[ -z "$mgr" ]] && return 0

  # 追加 iptables（CentOS7 nftables 常缺，iptables 必须在）
  local need_cmds=(ip tc ss awk sed grep cut tr uname date mkdir mv rm modprobe ps id curl head wc mktemp cat tar iptables)

  local missing=()
  for c in "${need_cmds[@]}"; do
    command -v "$c" >/dev/null 2>&1 || missing+=("$c")
  done
  [[ "${#missing[@]}" -eq 0 ]] && return 0

  echo -e "${YELLOW}检测到缺失依赖：${missing[*]}，尝试自动安装...${PLAIN}"

  if [[ "$mgr" == "dnf" || "$mgr" == "yum" ]]; then
    local pkgs=(iproute tar curl kmod procps-ng coreutils gawk grep sed util-linux iptables)
    pkgs+=(nftables) # 能装就装，装不了也不影响（有 iptables 兜底）
    install_pkgs "$mgr" "${pkgs[@]}" >/dev/null 2>&1 || true
  else
    install_pkgs "$mgr" iproute2 iproute2-tc tar curl kmod procps gawk grep sed coreutils util-linux iptables nftables >/dev/null 2>&1 || true
  fi

  for c in "${missing[@]}"; do
    command -v "$c" >/dev/null 2>&1 || { echo -e "${RED}缺少命令: $c${PLAIN}"; exit 1; }
  done

  echo -e "${GREEN}依赖已补齐（或已存在），继续执行...${PLAIN}\n"
}

# ----------------- 系统更新源（兼容 dnf/yum） -----------------
echo -e "${YELLOW}正在检测系统类型并更新软件源...${PLAIN}"
if [ -f /etc/debian_version ]; then
  echo -e "${BLUE}检测到 Debian/Ubuntu 系统，执行 apt-get update...${PLAIN}"
  apt-get update
elif [ -f /etc/redhat-release ]; then
  echo -e "${BLUE}检测到 CentOS/RedHat 系统，执行 makecache...${PLAIN}"
  if command -v dnf >/dev/null 2>&1; then
    dnf -y makecache
  else
    yum -y makecache
  fi
else
  echo -e "${RED}未识别的操作系统，跳过自动更新。${PLAIN}"
fi
echo -e "${GREEN}系统软件源更新完成！${PLAIN}\n"

# 先补依赖，再做强校验
ensure_deps

for cmd in ip tc ss awk sed grep cut tr uname date mkdir mv rm modprobe ps id curl head wc mktemp cat tar iptables; do
  command -v "$cmd" >/dev/null 2>&1 || { echo -e "${RED}缺少命令: $cmd${PLAIN}"; exit 1; }
done

has_nft(){ command -v nft >/dev/null 2>&1; }
has_iptables(){ command -v iptables >/dev/null 2>&1; }
has_flower(){ tc filter help 2>/dev/null | grep -qi flower; }

# nft/iptables 标记后端状态（用于菜单显示）
mark_status(){
  if has_nft; then echo -e "${GREEN}OK${PLAIN}"; return; fi
  if has_iptables; then echo -e "${GREEN}OK(iptables)${PLAIN}"; return; fi
  echo -e "${YELLOW}缺失${PLAIN}"
}

INTERFACE="$(ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}')"
[[ -z "$INTERFACE" ]] && echo -e "${RED}错误：无法识别主网卡（ip route get 8.8.8.8 失败）${PLAIN}" && exit 1
IFB_DEV="ifb0"

# TC Params
ROOT_RATE="10000mbit"
ROOT_QUANTUM=200000
USER_QUANTUM=15000
HTB_BURST="1m"
TBF_LATENCY_MS=50
TBF_MIN_BURST_BYTES=32768

DEFAULT_MINOR_HEX="fffe"
DEFAULT_CLASSID="1:${DEFAULT_MINOR_HEX}"

# Xray Params
XRAY_MARK_DEC="1"
NFT_TABLE="vps_tc"
NFT_CHAIN="out_mark"
XRAY_OUT_CLASSID="1:200"
XRAY_IN_CLASSID="1:201"

# DB
STATE_DIR="/var/lib/vps-tc"
DB_FILE="${STATE_DIR}/limits.db"
mkdir -p "$STATE_DIR" >/dev/null 2>&1 || true
touch "$DB_FILE" >/dev/null 2>&1 || true

# ---------------- utils ----------------
is_number(){ [[ "$1" =~ ^[0-9]+$ ]]; }
try_modprobe(){ modprobe "$1" >/dev/null 2>&1 || true; }

run_or_fail(){
  local msg="$1"; shift
  local err
  err="$("$@" 2>&1 >/dev/null)" || {
    echo -e "${RED}[FAIL]${PLAIN} $msg"
    [[ -n "$err" ]] && echo -e "${YELLOW}输出:${PLAIN} $err"
    return 1
  }
  return 0
}

# DB Ops
db_upsert(){
  local type="$1" key="$2" dir="$3" mbps="$4" meta="$5"
  local ts; ts="$(date +%F_%T)"
  grep -vE "^${type}\|${key}\|${dir}\|" "$DB_FILE" > "${DB_FILE}.tmp" 2>/dev/null || true
  mv -f "${DB_FILE}.tmp" "$DB_FILE" >/dev/null 2>&1 || true
  echo "${type}|${key}|${dir}|${mbps}|${ts}|${meta}" >> "$DB_FILE"
}
db_delete_prefix(){
  local type="$1" key="$2"
  grep -vE "^${type}\|${key}\|" "$DB_FILE" > "${DB_FILE}.tmp" 2>/dev/null || true
  mv -f "${DB_FILE}.tmp" "$DB_FILE" >/dev/null 2>&1 || true
}

# ---------------- iptables cleanup for XRAY mark ----------------
iptables_cleanup_xray_mark(){
  has_iptables || return 0
  # 删除 OUTPUT 链中 owner+MARK 的规则（只针对 set-mark=XRAY_MARK_DEC）
  # 将 -A 替换成 -D 逐条删除
  iptables -t mangle -S OUTPUT 2>/dev/null | \
    grep -E "^-A OUTPUT .* -m owner --uid-owner [0-9]+ .* -j MARK .*(${XRAY_MARK_DEC}|0x${XRAY_MARK_DEC})" | \
    while read -r line; do
      local del="${line/-A OUTPUT/-D OUTPUT}"
      iptables -t mangle $del >/dev/null 2>&1 || true
    done
  return 0
}

# ---------------- modules & init ----------------
init_modules(){
  try_modprobe ifb
  try_modprobe sch_htb
  try_modprobe sch_tbf
  try_modprobe sch_fq_codel
  try_modprobe act_mirred
  try_modprobe cls_u32
  try_modprobe cls_fw
  try_modprobe cls_flower
  # CentOS7: owner match 可能需要模块（失败无所谓）
  try_modprobe xt_owner
}

ensure_ifb(){
  if ! ip link show "$IFB_DEV" >/dev/null 2>&1; then
    run_or_fail "创建 IFB 失败" ip link add "$IFB_DEV" type ifb || return 1
  fi
  ip link set dev "$IFB_DEV" up >/dev/null 2>&1 || true
  return 0
}

ensure_ingress_redirect(){
  ensure_ifb || return 1
  if ! tc qdisc show dev "$INTERFACE" 2>/dev/null | grep -q "ffff:"; then
    run_or_fail "创建 ingress qdisc" tc qdisc add dev "$INTERFACE" handle ffff: ingress || return 1
  fi
  if ! tc filter show dev "$INTERFACE" parent ffff: 2>/dev/null | grep -q "protocol ip.*mirred.*redirect.*${IFB_DEV}"; then
    tc filter del dev "$INTERFACE" parent ffff: protocol ip prio 1 >/dev/null 2>&1 || true
    run_or_fail "IPv4 ingress redirect" tc filter add dev "$INTERFACE" parent ffff: protocol ip prio 1 u32 match u32 0 0 action mirred egress redirect dev "$IFB_DEV" || return 1
  fi
  if ! tc filter show dev "$INTERFACE" parent ffff: 2>/dev/null | grep -q "protocol ipv6.*mirred.*redirect.*${IFB_DEV}"; then
    tc filter del dev "$INTERFACE" parent ffff: protocol ipv6 prio 2 >/dev/null 2>&1 || true
    tc filter add dev "$INTERFACE" parent ffff: protocol ipv6 prio 2 u32 match u32 0 0 action mirred egress redirect dev "$IFB_DEV" >/dev/null 2>&1 || true
  fi
  return 0
}

ensure_htb_tree(){
  local dev="$1"
  if ! tc qdisc show dev "$dev" 2>/dev/null | grep -q "htb 1:"; then
    run_or_fail "Root HTB on $dev" tc qdisc add dev "$dev" root handle 1: htb default "$DEFAULT_MINOR_HEX" r2q 10 || return 1
  else
    tc qdisc replace dev "$dev" root handle 1: htb default "$DEFAULT_MINOR_HEX" r2q 10 >/dev/null 2>&1 || true
  fi
  if ! tc class show dev "$dev" 2>/dev/null | grep -q "1:1 "; then
    run_or_fail "Root Class 1:1" tc class add dev "$dev" parent 1: classid 1:1 htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" || return 1
  else
    tc class replace dev "$dev" parent 1:1 classid 1:1 htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" >/dev/null 2>&1 || true
  fi
  if ! tc class show dev "$dev" 2>/dev/null | grep -q "${DEFAULT_CLASSID} "; then
    run_or_fail "Default Class" tc class add dev "$dev" parent 1:1 classid "$DEFAULT_CLASSID" htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" || return 1
  else
    tc class replace dev "$dev" parent 1:1 classid "$DEFAULT_CLASSID" htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" >/dev/null 2>&1 || true
  fi
  tc qdisc replace dev "$dev" parent "$DEFAULT_CLASSID" handle fffe: fq_codel >/dev/null 2>&1 || true
  return 0
}

init_all(){
  init_modules
  ensure_htb_tree "$INTERFACE" || return 1
  ensure_ingress_redirect || return 1
  ensure_htb_tree "$IFB_DEV" || return 1
  return 0
}

attach_precise_leaf(){
  local dev="$1" classid="$2" handle_major_hex="$3" rate_kbit="$4"
  local burst_bytes=$(( rate_kbit * 25 / 10 ))
  [[ "$burst_bytes" -lt "$TBF_MIN_BURST_BYTES" ]] && burst_bytes="$TBF_MIN_BURST_BYTES"
  local latency="${TBF_LATENCY_MS}ms"
  local tbf_handle="${handle_major_hex}:"
  local inner_parent="${handle_major_hex}:1"

  tc qdisc del dev "$dev" parent "$classid" >/dev/null 2>&1 || true
  run_or_fail "Leaf TBF on $dev/$classid" tc qdisc add dev "$dev" parent "$classid" handle "$tbf_handle" tbf \
    rate "${rate_kbit}kbit" burst "${burst_bytes}" latency "$latency" || return 1
  tc qdisc replace dev "$dev" parent "$inner_parent" handle "${handle_major_hex}f:" fq_codel >/dev/null 2>&1 || true
  return 0
}

# ----------------- Allocation -----------------
minor_in_use(){ grep -E "minor=$1\s*$" "$DB_FILE" >/dev/null 2>&1; }
alloc_minor_for_port(){
  local port="$1"
  local start=$((1000 + (port % 50000)))
  local m="$start"; local tries=0
  while [[ "$tries" -lt 60000 ]]; do
    [[ "$m" -ge 65533 ]] && m=1000
    local hex; hex="$(printf '%x' "$m")"
    if ! minor_in_use "$hex"; then echo "$hex"; return 0; fi
    m=$((m+1)); tries=$((tries+1))
  done
  echo ""; return 1
}

# ----------------- 1) List Ports (Display Only) -----------------
list_active_ports(){
  echo -e "${YELLOW}[List] 扫描监听端口...${PLAIN}"
  echo -e "------------------------------------------------"
  printf "%-6s %-8s %-20s\n" "协议" "端口" "进程"
  echo -e "------------------------------------------------"
  while read -r proto state localaddr _peer process; do
    local tag="" color="$PLAIN"
    if [[ "$proto" == "tcp" && "$state" == "LISTEN" ]]; then tag="TCP"; color="$GREEN"
    elif [[ "$proto" == "udp" && "$state" == "UNCONN" ]]; then tag="UDP"; color="$BLUE"
    else continue; fi
    local port; port="$(echo "$localaddr" | awk -F':' '{print $NF}')"
    is_number "$port" || continue
    local pname; pname="$(echo "$process" | awk -F'"' '{print $2}')"
    [[ -z "$pname" ]] && pname="-"
    printf "${color}%-6s${PLAIN} %-8s %-20s\n" "$tag" "$port" "$pname"
  done < <(ss -H -tunlp 2>/dev/null | awk '{print $1, $2, $5, $6, $7}' | sort -k3 -t' ' -n)
  echo -e "------------------------------------------------"
}
menu_list_ports(){
  clear
  echo -e "${BLUE}--- 监听端口列表 ---${PLAIN}"
  list_active_ports
  read -p "按回车返回..."
}

# ----------------- 2) Xray Limits -----------------
detect_xray_uid_auto(){
  local uid
  uid="$(ps -eo comm,uid 2>/dev/null | awk '$1=="xray"{print $2; exit}')"
  [[ -z "$uid" ]] && uid="$(ps -eo comm,uid 2>/dev/null | awk '$1 ~ /^xray/ {print $2; exit}')"
  [[ -z "$uid" ]] && { id -u xray >/dev/null 2>&1 && uid="$(id -u xray)"; }
  echo "$uid"
}

# 原函数名保留（不改架构），内部增加 iptables 兜底
ensure_nft_mark_rule(){
  local uid="$1"

  # 1) nftables 优先
  if has_nft; then
    nft list table inet "$NFT_TABLE" >/dev/null 2>&1 || nft add table inet "$NFT_TABLE" >/dev/null 2>&1 || true
    if ! nft list chain inet "$NFT_TABLE" "$NFT_CHAIN" >/dev/null 2>&1; then
      nft add chain inet "$NFT_TABLE" "$NFT_CHAIN" "{ type filter hook output priority mangle; policy accept; }" >/dev/null 2>&1 || true
    fi
    if nft list chain inet "$NFT_TABLE" "$NFT_CHAIN" 2>/dev/null | grep -q "meta skuid .* meta mark set ${XRAY_MARK_DEC}"; then
      return 0
    fi
    run_or_fail "nft add rule" nft add rule inet "$NFT_TABLE" "$NFT_CHAIN" meta skuid "$uid" meta mark set "$XRAY_MARK_DEC" || return 1
    return 0
  fi

  # 2) CentOS7 常见：无 nftables -> 用 iptables mangle + owner 做标记
  if has_iptables; then
    # 规则是否存在
    iptables -t mangle -C OUTPUT -m owner --uid-owner "$uid" -j MARK --set-mark "$XRAY_MARK_DEC" >/dev/null 2>&1 && return 0
    run_or_fail "iptables add MARK rule" iptables -t mangle -A OUTPUT -m owner --uid-owner "$uid" -j MARK --set-mark "$XRAY_MARK_DEC" || return 1
    return 0
  fi

  echo -e "${RED}[FAIL]${PLAIN} nftables/iptables 均不可用，无法对 Xray 出站进行标记"
  return 1
}

apply_xray_out_limit(){
  local mbps="$1"
  local uid; uid="$(detect_xray_uid_auto)"
  if [[ -z "$uid" ]]; then
    echo -e "${YELLOW}警告：未能自动检测到 Xray 进程 UID。${PLAIN}"
    read -p "手动输入 UID (0取消): " input_uid
    if [[ -n "$input_uid" && "$input_uid" != "0" ]]; then uid="$input_uid"; else return 1; fi
  fi
  ensure_nft_mark_rule "$uid" || return 1

  local rate_kbit=$((mbps * 1000))
  local handle_hex="0200"

  tc filter del dev "$INTERFACE" parent 1:0 protocol all prio 10 >/dev/null 2>&1 || true
  tc qdisc  del dev "$INTERFACE" parent "$XRAY_OUT_CLASSID" >/dev/null 2>&1 || true
  tc class  del dev "$INTERFACE" parent 1:1 classid "$XRAY_OUT_CLASSID" >/dev/null 2>&1 || true

  run_or_fail "Class create" tc class add dev "$INTERFACE" parent 1:1 classid "$XRAY_OUT_CLASSID" htb rate "${rate_kbit}kbit" ceil "${rate_kbit}kbit" burst "$HTB_BURST" quantum "$USER_QUANTUM" || return 1
  attach_precise_leaf "$INTERFACE" "$XRAY_OUT_CLASSID" "$handle_hex" "$rate_kbit" || return 1
  run_or_fail "Filter add" tc filter add dev "$INTERFACE" parent 1:0 protocol all prio 10 handle "$XRAY_MARK_DEC" fw flowid "$XRAY_OUT_CLASSID" || return 1

  db_upsert "XRAY" "OUT" "out" "$mbps" "class=200,uid=$uid"
  echo -e "${GREEN}[Success]${PLAIN} Xray(UID:$uid) 总出站限制：${mbps} Mbps"
}

get_xray_listen_ports(){
  ss -H -tunlp 2>/dev/null | awk '$0 ~ /xray/ {print $1, $2, $5}' | while read -r proto state addr; do
    if [[ "$proto" == "tcp" && "$state" != "LISTEN" ]]; then continue; fi
    if [[ "$proto" == "udp" && "$state" != "UNCONN" ]]; then continue; fi
    port="$(echo "$addr" | awk -F':' '{print $NF}')"
    [[ "$port" =~ ^[0-9]+$ ]] && echo "$port"
  done | sort -n | uniq
}

apply_xray_in_limit(){
  local mbps="$1"
  local ports; ports="$(get_xray_listen_ports)"
  [[ -z "$ports" ]] && { echo -e "${RED}[FAIL]${PLAIN} 未检测到 xray 监听端口"; return 1; }

  local rate_kbit=$((mbps * 1000))
  local handle_hex="0201"

  tc qdisc del dev "$IFB_DEV" parent "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
  tc class del dev "$IFB_DEV" parent 1:1 classid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true

  run_or_fail "Class create" tc class add dev "$IFB_DEV" parent 1:1 classid "$XRAY_IN_CLASSID" htb rate "${rate_kbit}kbit" ceil "${rate_kbit}kbit" burst "$HTB_BURST" quantum "$USER_QUANTUM" || return 1
  attach_precise_leaf "$IFB_DEV" "$XRAY_IN_CLASSID" "$handle_hex" "$rate_kbit" || return 1

  while read -r p; do
    [[ -z "$p" ]] && continue
    tc filter del dev "$IFB_DEV" parent 1:0 protocol ip prio "$p" >/dev/null 2>&1 || true
    tc filter add dev "$IFB_DEV" parent 1:0 protocol ip prio "$p" u32 match ip dport "$p" 0xffff flowid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
    tc filter del dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$p" >/dev/null 2>&1 || true
    if has_flower; then
      tc filter add dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$p" flower ip_proto tcp dst_port "$p" flowid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
      tc filter add dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$p" flower ip_proto udp dst_port "$p" flowid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
    fi
  done <<< "$ports"

  db_upsert "XRAY" "IN" "in" "$mbps" "class=201"
  echo -e "${GREEN}[Success]${PLAIN} Xray 总入站限制：${mbps} Mbps"
}

menu_set_xray_limits(){
  echo -e "\n${BLUE}--- 限制 Xray 速度 ---${PLAIN}"
  echo -e "1) 仅限制 出站\n2) 仅限制 入站\n3) 限制 入站+出站"
  echo -e "0) 返回主菜单"
  read -p "选择: " sel
  if [[ "$sel" == "0" ]]; then return; fi

  read -p "输入速率(Mbps): " mbps
  if ! [[ "$mbps" =~ ^[0-9]+$ ]]; then
      echo -e "${RED}无效数字${PLAIN}"
      read -p "按回车返回..."
      return
  fi
  init_all || { echo -e "${RED}Init failed${PLAIN}"; read -p "按回车返回..."; return; }

  case "$sel" in
    1) apply_xray_out_limit "$mbps" ;;
    2) apply_xray_in_limit "$mbps" ;;
    3) apply_xray_out_limit "$mbps" && apply_xray_in_limit "$mbps" ;;
  esac
  read -p "操作完成，按回车返回..."
}

# ----------------- 3) Port Limits (Select Menu) -----------------
apply_port_limit_one(){
  local port="$1" dir="$2" mbps="$3"
  local rate_kbit=$((mbps * 1000))
  local minor_hex; minor_hex="$(alloc_minor_for_port "$port")"
  [[ -z "$minor_hex" ]] && { echo -e "${RED}ClassID 耗尽${PLAIN}"; return 1; }

  local classid="1:${minor_hex}"
  local handle_hex="$minor_hex"

  if [[ "$dir" == "out" ]]; then
    tc filter del dev "$INTERFACE" parent 1:0 protocol ip prio "$port" >/dev/null 2>&1 || true
    tc filter del dev "$INTERFACE" parent 1:0 protocol ipv6 prio "$port" >/dev/null 2>&1 || true
    tc class del dev "$INTERFACE" parent 1:1 classid "$classid" >/dev/null 2>&1 || true
    run_or_fail "Class create" tc class add dev "$INTERFACE" parent 1:1 classid "$classid" htb rate "${rate_kbit}kbit" ceil "${rate_kbit}kbit" burst "$HTB_BURST" quantum "$USER_QUANTUM" || return 1
    attach_precise_leaf "$INTERFACE" "$classid" "$handle_hex" "$rate_kbit" || return 1
    run_or_fail "Filter IPv4" tc filter add dev "$INTERFACE" parent 1:0 protocol ip prio "$port" u32 match ip protocol 6 0xff match ip sport "$port" 0xffff flowid "$classid" || return 1
    tc filter add dev "$INTERFACE" parent 1:0 protocol ip prio "$port" u32 match ip protocol 17 0xff match ip sport "$port" 0xffff flowid "$classid" >/dev/null 2>&1 || true
    if has_flower; then
      tc filter add dev "$INTERFACE" parent 1:0 protocol ipv6 prio "$port" flower ip_proto tcp src_port "$port" flowid "$classid" >/dev/null 2>&1 || true
      tc filter add dev "$INTERFACE" parent 1:0 protocol ipv6 prio "$port" flower ip_proto udp src_port "$port" flowid "$classid" >/dev/null 2>&1 || true
    fi
    db_upsert "PORT" "$port" "out" "$mbps" "minor=${minor_hex}"
    echo -e "${GREEN}[Success]${PLAIN} 端口 ${port} 出站限制：${mbps} Mbps"
    return 0
  fi

  if [[ "$dir" == "in" ]]; then
    tc filter del dev "$IFB_DEV" parent 1:0 protocol ip prio "$port" >/dev/null 2>&1 || true
    tc filter del dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$port" >/dev/null 2>&1 || true
    tc class del dev "$IFB_DEV" parent 1:1 classid "$classid" >/dev/null 2>&1 || true
    run_or_fail "Class create" tc class add dev "$IFB_DEV" parent 1:1 classid "$classid" htb rate "${rate_kbit}kbit" ceil "${rate_kbit}kbit" burst "$HTB_BURST" quantum "$USER_QUANTUM" || return 1
    attach_precise_leaf "$IFB_DEV" "$classid" "$handle_hex" "$rate_kbit" || return 1
    run_or_fail "Filter IPv4" tc filter add dev "$IFB_DEV" parent 1:0 protocol ip prio "$port" u32 match ip dport "$port" 0xffff flowid "$classid" || return 1
    if has_flower; then
      tc filter add dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$port" flower ip_proto tcp dst_port "$port" flowid "$classid" >/dev/null 2>&1 || true
      tc filter add dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$port" flower ip_proto udp dst_port "$port" flowid "$classid" >/dev/null 2>&1 || true
    fi
    db_upsert "PORT" "$port" "in" "$mbps" "minor=${minor_hex}"
    echo -e "${GREEN}[Success]${PLAIN} 端口 ${port} 入站限制：${mbps} Mbps"
    return 0
  fi
}

menu_port_limit(){
  echo -e "\n${BLUE}--- 特定端口限速 (支持序号点选) ---${PLAIN}"

  declare -a p_port p_proto p_name
  local idx=0
  local raw_data
  raw_data=$(ss -tunlp -H | awk '{
      proto=$1; addr=$5; proc=$7
      n=split(addr, a, ":"); port=a[n]
      split(proc, p, "\""); name=p[2]
      if (name == "") name="-"
      print port, proto, name
  }' | sort -k1,1n | uniq)

  echo -e "----------------------------------------------------------------"
  printf "${GREEN}%-6s %-8s %-10s %-20s${PLAIN}\n" "序号" "协议" "端口" "进程"
  echo -e "----------------------------------------------------------------"

  if [[ -z "$raw_data" ]]; then
      echo -e "${YELLOW}未检测到活动端口${PLAIN}"
  else
      while read -r port proto name; do
          idx=$((idx+1))
          p_port[$idx]="$port"
          p_proto[$idx]="$proto"
          p_name[$idx]="$name"
          local color="$PLAIN"
          [[ "$proto" == "tcp" ]] && color="$GREEN"
          [[ "$proto" == "udp" ]] && color="$BLUE"
          printf "[%d]    ${color}%-8s${PLAIN} %-10s %-20s\n" "$idx" "${proto^^}" "$port" "$name"
      done <<< "$raw_data"
  fi

  echo -e "----------------------------------------------------------------"
  echo -e "${GREEN}[0]${PLAIN}    返回主菜单"
  echo -e "${GREEN}[m]${PLAIN}    手动输入端口号"
  echo -e "----------------------------------------------------------------"

  read -p "请输入序号/m/0 : " sel
  local target_port=""

  if [[ "$sel" == "0" ]]; then
      return
  elif [[ "$sel" == "m" ]]; then
      read -p "请输入端口号: " input_p
      target_port="$input_p"
  elif [[ "$sel" =~ ^[0-9]+$ ]] && [[ "$sel" -le "$idx" ]] && [[ "$sel" -gt 0 ]]; then
      target_port="${p_port[$sel]}"
      echo -e "已选择: 端口 ${GREEN}${target_port}${PLAIN} (${p_name[$sel]})"
  else
      echo -e "${RED}输入无效${PLAIN}"
      read -p "按回车返回..."
      return
  fi

  if ! is_number "$target_port" || [[ "$target_port" -le 0 || "$target_port" -gt 65535 ]]; then
      echo -e "${RED}端口无效: $target_port${PLAIN}"
      read -p "按回车返回..."
      return
  fi

  echo -e "\n1) 仅限制 出站/下行\n2) 仅限制 入站/上行\n3) 限制 入站+出站"
  read -p "选择: " sel
  read -p "速率(Mbps): " mbps

  if ! [[ "$mbps" =~ ^[0-9]+$ ]]; then
      echo -e "${RED}无效数字${PLAIN}"
      read -p "按回车返回..."
      return
  fi

  init_all || { echo -e "${RED}Init failed${PLAIN}"; read -p "按回车返回..."; return; }
  case "$sel" in
    1) apply_port_limit_one "$target_port" "out" "$mbps" ;;
    2) apply_port_limit_one "$target_port" "in"  "$mbps" ;;
    3) apply_port_limit_one "$target_port" "out" "$mbps" && apply_port_limit_one "$target_port" "in" "$mbps" ;;
  esac
  read -p "操作完成，按回车返回..."
}

# ----------------- 4) Port Limits (Remove) -----------------
remove_port_limit_exec(){
  local port="$1"
  local found=0
  if grep -qE "^PORT\|${port}\|" "$DB_FILE"; then found=1; fi
  if [[ "$found" -eq 0 ]]; then echo -e "${YELLOW}未找到端口 ${port} 的限速记录${PLAIN}"; return; fi

  tc filter del dev "$INTERFACE" parent 1:0 protocol ip prio "$port" >/dev/null 2>&1 || true
  tc filter del dev "$INTERFACE" parent 1:0 protocol ipv6 prio "$port" >/dev/null 2>&1 || true
  tc filter del dev "$IFB_DEV" parent 1:0 protocol ip prio "$port" >/dev/null 2>&1 || true
  tc filter del dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$port" >/dev/null 2>&1 || true

  while IFS='|' read -r type key dir mbps ts meta; do
    if [[ "$type" == "PORT" && "$key" == "$port" ]]; then
       local m; m="$(echo "$meta" | grep -o "minor=[0-9a-f]*" | cut -d= -f2)"
       if [[ -n "$m" ]]; then
         local classid="1:$m"
         if [[ "$dir" == "out" ]]; then
           tc qdisc del dev "$INTERFACE" parent "$classid" >/dev/null 2>&1 || true
           tc class del dev "$INTERFACE" parent 1:1 classid "$classid" >/dev/null 2>&1 || true
         elif [[ "$dir" == "in" ]]; then
           tc qdisc del dev "$IFB_DEV" parent "$classid" >/dev/null 2>&1 || true
           tc class del dev "$IFB_DEV" parent 1:1 classid "$classid" >/dev/null 2>&1 || true
         fi
       fi
    fi
  done < "$DB_FILE"

  db_delete_prefix "PORT" "$port"
  echo -e "${GREEN}已移除端口 ${port} 的所有限速规则${PLAIN}"
}

menu_remove_port_limit(){
  echo -e "\n${BLUE}--- 移除 特定端口 限速 (支持序号点选) ---${PLAIN}"
  if [[ ! -s "$DB_FILE" ]] || ! grep -q "^PORT|" "$DB_FILE"; then
      echo -e "${YELLOW}(当前无端口限速记录)${PLAIN}"
      read -p "按回车返回..."
      return
  fi

  echo -e "--------------------------------------------------------"
  printf "${GREEN}%-6s %-10s %-12s %-10s${PLAIN}\n" "序号" "端口" "方向" "限速"
  echo -e "--------------------------------------------------------"

  declare -a r_list_port
  local idx=0

  while IFS='|' read -r type port dir mbps ts meta; do
    if [[ "$type" == "PORT" ]]; then
        idx=$((idx+1))
        r_list_port[$idx]="$port"

        local d_str="未知"
        if [[ "$dir" == "out" ]]; then d_str="out(下行)"; fi
        if [[ "$dir" == "in" ]]; then d_str="in(上行)"; fi

        printf "[%d]    %-10s %-12s %-10s\n" "$idx" "$port" "$d_str" "${mbps}Mbps"
    fi
  done < "$DB_FILE"
  echo -e "--------------------------------------------------------"

  echo -e "${GREEN}[0]${PLAIN}    返回主菜单"
  echo -e "${GREEN}[输入]${PLAIN} 请输入序号 或 端口号:"
  read -p "选择: " input_val

  if [[ "$input_val" == "0" ]]; then return; fi

  local target_port=""
  if [[ "$input_val" =~ ^[0-9]+$ ]] && [[ "$input_val" -le "$idx" ]] && [[ "$input_val" -gt 0 ]]; then
      target_port="${r_list_port[$input_val]}"
      if [[ -z "$target_port" ]]; then target_port="$input_val"; fi
  else
      target_port="$input_val"
  fi

  if ! is_number "$target_port"; then
      echo -e "${RED}输入无效${PLAIN}"
      read -p "按回车返回..."
      return
  fi

  echo -e "即将移除端口 ${GREEN}${target_port}${PLAIN} 的所有限速规则..."
  init_all >/dev/null 2>&1 || true
  remove_port_limit_exec "$target_port"
  read -p "操作完成，按回车返回..."
}

# ----------------- 5) Show List -----------------
show_limits(){
  clear
  echo -e "${BLUE}--- 当前限速清单 ---${PLAIN}"
  echo -e "网卡: ${GREEN}${INTERFACE}${PLAIN} | IFB: ${GREEN}${IFB_DEV}${PLAIN}"
  printf "%-8s %-8s %-6s %-8s %-20s\n" "类型" "对象" "方向" "速率" "备注"
  echo -e "--------------------------------------------------------"
  [[ ! -s "$DB_FILE" ]] && echo -e "${YELLOW}(空)${PLAIN}"
  while IFS='|' read -r type key dir mbps ts meta; do
    printf "%-8s %-8s %-6s %-8s %-20s\n" "$type" "$key" "$dir" "${mbps}M" "$meta"
  done < "$DB_FILE"
  echo -e "--------------------------------------------------------"
  read -p "按回车返回..."
}

# ----------------- 6) Remove Xray Limits -----------------
menu_remove_xray_limits(){
  echo -e "\n${BLUE}--- 移除 Xray 限速 ---${PLAIN}"
  echo -e "1) 移除 出站\n2) 移除 入站\n3) 全部移除"
  echo -e "0) 返回主菜单"
  read -p "选择: " sel
  if [[ "$sel" == "0" ]]; then return; fi

  init_all >/dev/null 2>&1 || true

  [[ "$sel" == "1" || "$sel" == "3" ]] && {
     tc filter del dev "$INTERFACE" parent 1:0 protocol all prio 10 >/dev/null 2>&1 || true
     tc qdisc  del dev "$INTERFACE" parent "$XRAY_OUT_CLASSID" >/dev/null 2>&1 || true
     tc class  del dev "$INTERFACE" parent 1:1 classid "$XRAY_OUT_CLASSID" >/dev/null 2>&1 || true

     # nft 规则清理
     has_nft && nft delete table inet "$NFT_TABLE" >/dev/null 2>&1 || true
     # iptables 兜底清理
     iptables_cleanup_xray_mark

     db_delete_prefix "XRAY" "OUT"
     echo -e "${GREEN}Xray 出站限制已移除${PLAIN}"
  }

  [[ "$sel" == "2" || "$sel" == "3" ]] && {
     tc qdisc del dev "$IFB_DEV" parent "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
     tc class del dev "$IFB_DEV" parent 1:1 classid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
     db_delete_prefix "XRAY" "IN"
     echo -e "${GREEN}Xray 入站限制已移除${PLAIN}"
  }

  read -p "操作完成，按回车返回..."
}

# ----------------- 7) Reset All -----------------
reset_all(){
  tc qdisc del dev "$INTERFACE" root >/dev/null 2>&1 || true
  tc qdisc del dev "$INTERFACE" ingress >/dev/null 2>&1 || true
  tc qdisc del dev "$IFB_DEV" root >/dev/null 2>&1 || true
  ip link set dev "$IFB_DEV" down >/dev/null 2>&1 || true
  ip link del dev "$IFB_DEV" >/dev/null 2>&1 || true

  # nft/iptables 清理（CentOS7 关键）
  has_nft && nft delete table inet "$NFT_TABLE" >/dev/null 2>&1 || true
  iptables_cleanup_xray_mark

  : > "$DB_FILE"
  echo -e "${GREEN}已重置所有 TC/NFT/iptables 规则${PLAIN}"
  read -p "操作完成，按回车返回..."
}

# ----------------- 8) Speedtest -----------------
install_ookla_speedtest(){
  echo -e "${YELLOW}检测到未安装 speedtest，正在安装...${PLAIN}"
  local tmpdir; tmpdir="$(mktemp -d)"
  local logf="${tmpdir}/speedtest_install.log"
  local installed=0

  SPIN_CHARS='|/-\'
  run_with_spinner() {
    local msg="$1"; shift
    local lf="$1"; shift
    local i=0
    echo -ne "${CYAN}${msg}${PLAIN} "
    ( "$@" ) >"$lf" 2>&1 &
    local pid=$!
    while kill -0 "$pid" 2>/dev/null; do
      printf "\b%s" "${SPIN_CHARS:i%4:1}"
      i=$((i+1))
      sleep 0.1
    done
    wait "$pid"; local rc=$?
    if [[ $rc -eq 0 ]]; then echo -e "\b${GREEN}OK${PLAIN}"; else echo -e "\b${RED}FAIL${PLAIN}"; fi
    return $rc
  }
  curl_dl_bar() { curl -L --fail --progress-bar -o "$2" "$1"; }
  tail_log_hint() {
    echo -e "${YELLOW}--- 安装日志(最后 80 行) ---${PLAIN}"
    tail -n 80 "$1" 2>/dev/null || true
    echo -e "${YELLOW}---------------------------${PLAIN}"
  }

  if [ -f /etc/debian_version ]; then
    run_with_spinner "配置并安装 speedtest(apt)..." "$logf" bash -c '
      set -e
      curl -fsSL https://packagecloud.io/install/repositories/ookla/speedtest-cli/script.deb.sh | bash
      apt-get update -y
      DEBIAN_FRONTEND=noninteractive apt-get install -y speedtest
    ' && installed=1
  elif [ -f /etc/redhat-release ]; then
    if command -v dnf >/dev/null 2>&1; then
      run_with_spinner "配置并安装 speedtest(dnf)..." "$logf" bash -c '
        set -e
        curl -fsSL https://packagecloud.io/install/repositories/ookla/speedtest-cli/script.rpm.sh | bash
        dnf -y makecache
        dnf -y install speedtest
      ' && installed=1
    else
      run_with_spinner "配置并安装 speedtest(yum)..." "$logf" bash -c '
        set -e
        curl -fsSL https://packagecloud.io/install/repositories/ookla/speedtest-cli/script.rpm.sh | bash
        yum -y makecache
        yum -y install speedtest
      ' && installed=1
    fi
  fi

  if [[ "$installed" -eq 0 ]]; then
    echo -e "${YELLOW}Repo 安装失败，切换到官方二进制包安装（下载带真实进度条）...${PLAIN}"
    tail_log_hint "$logf"

    local arch; arch="$(uname -m)"
    local url=""
    case "$arch" in
      x86_64) url="https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-x86_64.tgz" ;;
      aarch64|arm64) url="https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-aarch64.tgz" ;;
      *) echo -e "${RED}不支持的架构: ${arch}${PLAIN}"; rm -rf "$tmpdir"; return 1 ;;
    esac

    local tgz="${tmpdir}/speedtest.tgz"
    echo -e "${CYAN}下载 speedtest 二进制包中...${PLAIN}"
    if ! curl_dl_bar "$url" "$tgz"; then
      echo -e "${RED}下载失败：无法访问 install.speedtest.net${PLAIN}"
      rm -rf "$tmpdir"
      return 1
    fi

    echo -e "${CYAN}解压并安装中...${PLAIN}"
    tar -xzf "$tgz" -C "$tmpdir" >/dev/null 2>&1 || { echo -e "${RED}解压失败${PLAIN}"; rm -rf "$tmpdir"; return 1; }

    if [[ -f "${tmpdir}/speedtest" ]]; then
      mv -f "${tmpdir}/speedtest" /usr/bin/speedtest
      chmod +x /usr/bin/speedtest
      installed=1
    else
      echo -e "${RED}安装失败：解压后未找到 speedtest 可执行文件${PLAIN}"
      rm -rf "$tmpdir"
      return 1
    fi
  fi

  rm -rf "$tmpdir"
  command -v speedtest >/dev/null 2>&1 || return 1
  return 0
}

run_ookla_speedtest(){
  if ! command -v speedtest >/dev/null 2>&1; then
    install_ookla_speedtest || { echo -e "${RED}安装失败${PLAIN}"; read -p "回车返回..."; return; }
  fi

  echo -e "\n${BLUE}========== Speedtest by Ookla (Global + Domestic) ==========${PLAIN}"

  echo -e "${YELLOW}--- 中国国内 (China) ---${PLAIN}"
  printf "%-36s | %-36s\n" " 1) 3633  (电信|上海)" " 2) 27594 (电信|南京)"
  printf "%-36s | %-36s\n" " 3) 27377 (电信|合肥)" " 4) 24447 (联通|上海)"
  printf "%-36s | %-36s\n" " 5) 4870  (联通|长沙)" " 6) 16803 (移动|上海)"
  printf "%-36s | %-36s\n" " 7) 25858 (移动|北京)" " 8) 55299 (广电|南京)"
  printf "%-36s\n" " 9) 58529 (广电|北京)"

  echo -e "\n${YELLOW}--- 亚洲 (Asia) ---${PLAIN}"
  printf "%-36s | %-36s\n" "10) 13538 (香港|STC)" "11) 1536  (香港|CSL)"
  printf "%-36s | %-36s\n" "12) 18445 (台湾|中华电信)" "13) 21569 (日本|IPA)"
  printf "%-36s | %-36s\n" "14) 48463 (日本|Rakuten)" "15) 26685 (韩国|Kdatacenter)"
  printf "%-36s\n" "16) 13623 (新加坡|Singtel)"

  echo -e "\n${YELLOW}--- 欧美/其他 (Global Others) ---${PLAIN}"
  printf "%-36s | %-36s\n" "17) 17383 (美国|洛杉矶)" "18) 14236 (美国|圣何塞)"
  printf "%-36s | %-36s\n" "19) 5029  (美国|纽约)" "20) 30537 (加拿大|Rogers)"
  printf "%-36s | %-36s\n" "21) 35055 (英国|伦敦)" "22) 31120 (德国|法兰克福)"
  printf "%-36s | %-36s\n" "23) 1688  (法国|Bouygues)" "24) 5252  (荷兰|KPN)"

  echo -e "------------------------------------------------------------------------"
  echo -e "0) 返回主菜单"
  read -p "请输入序号/ID (直接回车自动, 0返回): " selection
  if [[ "$selection" == "0" ]]; then return; fi

  local sid=""
  case "$selection" in
    1) sid="3633" ;;
    2) sid="27594" ;;
    3) sid="27377" ;;
    4) sid="24447" ;;
    5) sid="4870" ;;
    6) sid="16803" ;;
    7) sid="25858" ;;
    8) sid="55299" ;;
    9) sid="58529" ;;
    10) sid="13538" ;;
    11) sid="1536" ;;
    12) sid="18445" ;;
    13) sid="21569" ;;
    14) sid="48463" ;;
    15) sid="26685" ;;
    16) sid="13623" ;;
    17) sid="17383" ;;
    18) sid="14236" ;;
    19) sid="5029" ;;
    20) sid="30537" ;;
    21) sid="35055" ;;
    22) sid="31120" ;;
    23) sid="1688" ;;
    24) sid="5252" ;;
    "") sid="" ;;
    *) sid="$selection" ;;
  esac

  if [[ ! -f ~/.config/ookla/speedtest-cli.json ]]; then speedtest --accept-license --accept-gdpr >/dev/null 2>&1; fi
  echo -e "${CYAN}正在连接测速服务器...${PLAIN}\n"
  if [[ -n "$sid" ]]; then speedtest --server-id="$sid" --progress=yes; else speedtest --progress=yes; fi
  echo -e "${BLUE}========================================${PLAIN}"
  read -p "测试完成，按回车返回..."
}

# ----------------- 9) Monitor -----------------
monitor_stats(){
  clear
  while true; do
    if command -v tput >/dev/null 2>&1; then tput cup 0 0; else clear; fi
    echo -e "${BLUE}=== 实时流量监控 [按回车返回] ===${PLAIN}"
    echo -e "刷新时间: $(date +%T)"
    echo -e "----------------------------------------------------"
    printf "%-6s %-6s %-4s %-8s %-10s %-8s\n" "TYPE" "PORT" "DIR" "LIMIT" "SENT" "DROP"
    echo -e "----------------------------------------------------"
    if [[ ! -s "$DB_FILE" ]]; then
      echo -e "${YELLOW}   (当前无限速规则)${PLAIN}"; echo ""; echo ""
    else
      while IFS='|' read -r type key dir mbps ts meta; do
         local dev="$INTERFACE"; local classid=""; local sent="-"; local dropped="0"
         if [[ "$type" == "XRAY" && "$dir" == "out" ]]; then classid="1:200"; fi
         if [[ "$type" == "XRAY" && "$dir" == "in" ]]; then dev="$IFB_DEV"; classid="1:201"; fi
         if [[ "$type" == "PORT" ]]; then
             local m; m="$(echo "$meta" | grep -o "minor=[0-9a-f]*" | cut -d= -f2)"
             [[ -n "$m" ]] && classid="1:$m"; [[ "$dir" == "in" ]] && dev="$IFB_DEV"
         fi
         if [[ -n "$classid" ]]; then
           local raw; raw="$(tc -s class show dev "$dev" classid "$classid" 2>/dev/null)"
           if [[ -n "$raw" ]]; then
             local bytes; bytes="$(echo "$raw" | grep -oP 'Sent \K[0-9]+' | head -1)"
             if [[ -n "$bytes" ]]; then
               if [[ "$bytes" -gt 1073741824 ]]; then sent="$(awk -v b="$bytes" 'BEGIN{printf "%.1fG", b/1073741824}')"
               elif [[ "$bytes" -gt 1048576 ]]; then sent="$(awk -v b="$bytes" 'BEGIN{printf "%.1fM", b/1048576}')"
               elif [[ "$bytes" -gt 1024 ]]; then sent="$(awk -v b="$bytes" 'BEGIN{printf "%.0fK", b/1024}')"
               else sent="${bytes}"; fi
             fi
             local drop; drop="$(echo "$raw" | grep -oP 'dropped \K[0-9]+' | head -1)"
             [[ -n "$drop" ]] && dropped="$drop"
           fi
         fi
         printf "%-6s %-6s %-4s %-8s %-10s " "$type" "$key" "$dir" "${mbps}M" "$sent"
         if [[ "$dropped" != "0" && "$dropped" != "-" ]]; then echo -e "${RED}${dropped}${PLAIN}"; else echo -e "${dropped}"; fi
      done < "$DB_FILE"
    fi
    echo -e "----------------------------------------------------"
    read -t 2 -n 1 -s -r; if [[ $? -eq 0 ]]; then break; fi
  done
}

# ----------------- 10) Uninstall -----------------
do_uninstall(){
  echo -e "${RED}警告：这将清除所有限速规则并删除脚本配置文件！${PLAIN}"
  read -p "确定要继续吗? (y/N): " confirm
  [[ "$confirm" != "y" ]] && return
  reset_all
  rm -rf "$STATE_DIR"
  echo -e "${GREEN}卸载完成。${PLAIN}"; echo -e "你可以手动删除此脚本: rm $0"; exit 0
}

# ----------------- Menu -----------------
show_menu(){
  clear
  echo -e "=================================================="
  echo -e "   VPS 流量控制台 V10.22 (Zero-Latency Return)"
  echo -e "   网卡: ${GREEN}${INTERFACE}${PLAIN} | IFB: ${GREEN}${IFB_DEV}${PLAIN}"
  echo -e "   nftables: $(mark_status)"
  echo -e "=================================================="
  echo -e "1. 监听端口 (列表)"
  echo -e "2. 限制 Xray 速度 (Docker/UID)"
  echo -e "3. 限制 特定端口 速率 (序号点选)"
  echo -e "4. 移除 特定端口 限速 (支持序号)"
  echo -e "5. 查看限速清单"
  echo -e "6. 移除 Xray 限速"
  echo -e "7. 全部重置 (Reset)"
  echo -e "--------------------------------------------------"
  echo -e "8. Speedtest (国内+广电+国际)"
  echo -e "9. 实时流量监控 (Live Monitor)"
  echo -e "10. 彻底卸载与清理"
  echo -e "0. 退出"
  echo -e "=================================================="
  read -p "选择: " c

  case "$c" in
    1) menu_list_ports ;;
    2) menu_set_xray_limits ;;
    3) menu_port_limit ;;
    4) menu_remove_port_limit ;;
    5) show_limits ;;
    6) menu_remove_xray_limits ;;
    7) reset_all ;;
    8) run_ookla_speedtest ;;
    9) monitor_stats ;;
    10) do_uninstall ;;
    0) exit 0 ;;
    *) show_menu ;;
  esac
  show_menu
}

show_menu
