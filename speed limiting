#!/bin/bash
# ==================================================
# VPS 流量控制台 V10.4 (3x-ui / Xray + Per-Port Shaping + UI-like Speedtest)
#
# 功能：
# 1) 监听目前所有端口（TCP/UDP，支持编号点选）
# 2) 限制 Xray 总出站/总入站速度（可分开设置）
# 3) 限制 特定端口 速率（上下行可分开设置）
# 4) 查看当前所有端口/项目的限速情况（清单）
# 5) 移除 Xray 的限速（入站/出站）
# 6) 全部重置（恢复脚本修改的所有项目）
# 7) Speedtest（指定端口；固定 500MB；上下行分开；“更像测速UI”的进度显示）
# 0) 退出
#
# 关键修复：
# - 修复 classid/handle 溢出导致的 “创建 TBF 失败”：改用 minor 分配器，保证 <= fffd
# - Speedtest：保留进度输出（stderr），耗时写临时文件避免破坏进度显示
# ==================================================

set -u

RED='\033[31m'
GREEN='\033[32m'
YELLOW='\033[33m'
BLUE='\033[36m'
PLAIN='\033[0m'

[[ ${EUID:-999} -ne 0 ]] && echo -e "${RED}错误：请使用 root 用户运行！${PLAIN}" && exit 1

for cmd in ip tc ss awk sed grep cut tr uname date mkdir mv rm modprobe ps id curl head wc mktemp cat; do
  command -v "$cmd" >/dev/null 2>&1 || { echo -e "${RED}缺少命令: $cmd${PLAIN}"; exit 1; }
done

has_nft(){ command -v nft >/dev/null 2>&1; }
has_flower(){ tc filter help 2>/dev/null | grep -qi flower; }

INTERFACE="$(ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}')"
[[ -z "$INTERFACE" ]] && echo -e "${RED}错误：无法识别主网卡（ip route get 8.8.8.8 失败）${PLAIN}" && exit 1
IFB_DEV="ifb0"

# shaping params
ROOT_RATE="10000mbit"
ROOT_QUANTUM=200000
USER_QUANTUM=15000
HTB_BURST="1m"
TBF_LATENCY_MS=50
TBF_MIN_BURST_BYTES=32768

DEFAULT_MINOR_HEX="fffe"
DEFAULT_CLASSID="1:${DEFAULT_MINOR_HEX}"

# xray
XRAY_MARK_DEC="1"
NFT_TABLE="vps_tc"
NFT_CHAIN="out_mark"
XRAY_OUT_CLASSID="1:200"
XRAY_IN_CLASSID="1:201"

# state db
STATE_DIR="/var/lib/vps-tc"
DB_FILE="${STATE_DIR}/limits.db"   # type|key|dir|mbps|ts|meta
mkdir -p "$STATE_DIR" >/dev/null 2>&1 || true
touch "$DB_FILE" >/dev/null 2>&1 || true

# speedtest fixed payloads
SPEEDTEST_MB=500
SPEEDTEST_BYTES=$((SPEEDTEST_MB * 1000000))

SELECTED_PORT=""

# ---------------- utils ----------------
is_number(){ [[ "$1" =~ ^[0-9]+$ ]]; }

try_modprobe(){ modprobe "$1" >/dev/null 2>&1 || true; }

# 打印 stderr 以便定位（tc 常见失败点）
run_or_fail(){
  local msg="$1"; shift
  local err
  err="$("$@" 2>&1 >/dev/null)" || {
    echo -e "${RED}[FAIL]${PLAIN} $msg"
    [[ -n "$err" ]] && echo -e "${YELLOW}输出:${PLAIN} $err"
    return 1
  }
  return 0
}

# DB
db_upsert(){
  local type="$1" key="$2" dir="$3" mbps="$4" meta="$5"
  local ts; ts="$(date +%F_%T)"
  grep -vE "^${type}\|${key}\|${dir}\|" "$DB_FILE" > "${DB_FILE}.tmp" 2>/dev.glide || true
  mv -f "${DB_FILE}.tmp" "$DB_FILE" >/dev/null 2>&1 || true
  echo "${type}|${key}|${dir}|${mbps}|${ts}|${meta}" >> "$DB_FILE"
}
db_delete_prefix(){
  local type="$1" key="$2"
  grep -vE "^${type}\|${key}\|" "$DB_FILE" > "${DB_FILE}.tmp" 2>/dev/null || true
  mv -f "${DB_FILE}.tmp" "$DB_FILE" >/dev/null 2>&1 || true
}
db_delete_exact(){
  local type="$1" key="$2" dir="$3"
  grep -vE "^${type}\|${key}\|${dir}\|" "$DB_FILE" > "${DB_FILE}.tmp" 2>/dev/null || true
  mv -f "${DB_FILE}.tmp" "$DB_FILE" >/dev/null 2>&1 || true
}

# ---------------- modules ----------------
init_modules(){
  try_modprobe ifb
  try_modprobe sch_htb
  try_modprobe sch_tbf
  try_modprobe sch_fq_codel
  try_modprobe act_mirred
  try_modprobe cls_u32
  try_modprobe cls_fw
  try_modprobe cls_flower
}

# ---------------- tc init ----------------
ensure_ifb(){
  if ! ip link show "$IFB_DEV" >/dev/null 2>&1; then
    run_or_fail "创建 IFB($IFB_DEV) 失败（内核不支持 ifb 或权限问题）" ip link add "$IFB_DEV" type ifb || return 1
  fi
  ip link set dev "$IFB_DEV" up >/dev/null 2>&1 || true
  return 0
}

ensure_ingress_redirect(){
  ensure_ifb || return 1

  if ! tc qdisc show dev "$INTERFACE" 2>/dev/null | grep -q "ffff:"; then
    run_or_fail "创建 ingress qdisc 失败" tc qdisc add dev "$INTERFACE" handle ffff: ingress || return 1
  fi

  if ! tc filter show dev "$INTERFACE" parent ffff: 2>/dev/null | grep -q "protocol ip.*mirred.*redirect.*${IFB_DEV}"; then
    tc filter del dev "$INTERFACE" parent ffff: protocol ip prio 1 >/dev/null 2>&1 || true
    run_or_fail "设置 IPv4 ingress redirect 失败" tc filter add dev "$INTERFACE" parent ffff: protocol ip prio 1 u32 \
      match u32 0 0 action mirred egress redirect dev "$IFB_DEV" || return 1
  fi

  # IPv6 best-effort
  if ! tc filter show dev "$INTERFACE" parent ffff: 2>/dev/null | grep -q "protocol ipv6.*mirred.*redirect.*${IFB_DEV}"; then
    tc filter del dev "$INTERFACE" parent ffff: protocol ipv6 prio 2 >/dev/null 2>&1 || true
    tc filter add dev "$INTERFACE" parent ffff: protocol ipv6 prio 2 u32 \
      match u32 0 0 action mirred egress redirect dev "$IFB_DEV" >/dev/null 2>&1 || true
  fi

  return 0
}

ensure_htb_tree(){
  local dev="$1"
  if ! tc qdisc show dev "$dev" 2>/dev/null | grep -q "htb 1:"; then
    run_or_fail "在 $dev 创建 root HTB 失败" tc qdisc add dev "$dev" root handle 1: htb default "$DEFAULT_MINOR_HEX" r2q 10 || return 1
  else
    tc qdisc replace dev "$dev" root handle 1: htb default "$DEFAULT_MINOR_HEX" r2q 10 >/dev/null 2>&1 || true
  fi

  if ! tc class show dev "$dev" 2>/dev/null | grep -q "1:1 "; then
    run_or_fail "在 $dev 创建 class 1:1 失败" tc class add dev "$dev" parent 1: classid 1:1 htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" || return 1
  else
    tc class replace dev "$dev" parent 1: classid 1:1 htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" >/dev/null 2>&1 || true
  fi

  if ! tc class show dev "$dev" 2>/dev/null | grep -q "${DEFAULT_CLASSID} "; then
    run_or_fail "在 $dev 创建 default class 失败" tc class add dev "$dev" parent 1:1 classid "$DEFAULT_CLASSID" htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" || return 1
  else
    tc class replace dev "$dev" parent 1:1 classid "$DEFAULT_CLASSID" htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" >/dev/null 2>&1 || true
  fi

  tc qdisc replace dev "$dev" parent "$DEFAULT_CLASSID" handle fffe: fq_codel >/dev/null 2>&1 || true
  return 0
}

init_all(){
  init_modules
  ensure_htb_tree "$INTERFACE" || return 1
  ensure_ingress_redirect || return 1
  ensure_htb_tree "$IFB_DEV" || return 1
  return 0
}

attach_precise_leaf(){
  local dev="$1" classid="$2" handle_major_hex="$3" rate_kbit="$4"
  local burst_bytes=$(( rate_kbit * 25 / 10 ))
  [[ "$burst_bytes" -lt "$TBF_MIN_BURST_BYTES" ]] && burst_bytes="$TBF_MIN_BURST_BYTES"
  local latency="${TBF_LATENCY_MS}ms"

  local tbf_handle="${handle_major_hex}:"
  local inner_parent="${handle_major_hex}:1"

  tc qdisc del dev "$dev" parent "$classid" >/dev/null 2>&1 || true
  run_or_fail "在 $dev/$classid 创建 TBF 失败" tc qdisc add dev "$dev" parent "$classid" handle "$tbf_handle" tbf \
    rate "${rate_kbit}kbit" burst "${burst_bytes}" latency "$latency" || return 1
  tc qdisc replace dev "$dev" parent "$inner_parent" handle "${handle_major_hex}f:" fq_codel >/dev/null 2>&1 || true
  return 0
}

# ==================================================
# ID allocator (fix overflow)
# ==================================================
minor_in_use(){
  local minor_hex="$1"
  grep -E "minor=${minor_hex}\s*$" "$DB_FILE" >/dev/null 2>&1
}

alloc_minor_for_port(){
  local port="$1"
  local start=$((1000 + (port % 50000)))
  local m="$start"
  local tries=0
  while [[ "$tries" -lt 60000 ]]; do
    [[ "$m" -ge 65533 ]] && m=1000
    local hex; hex="$(printf '%x' "$m")"
    if ! minor_in_use "$hex"; then
      echo "$hex"
      return 0
    fi
    m=$((m+1))
    tries=$((tries+1))
  done
  echo ""
  return 1
}

# ==================================================
# 1) Listening ports (keep numeric selection)
# ==================================================
select_active_port(){
  echo -e "${YELLOW}[List] 正在扫描监听端口(TCP/UDP)...${PLAIN}"
  echo -e "------------------------------------------------"
  printf "%-5s %-6s %-8s %-20s\n" "编号" "协议" "端口" "进程"
  echo -e "------------------------------------------------"

  declare -a plist
  declare -a proto_list
  local idx=1

  while read -r proto state localaddr _peer process; do
    local tag="" color="$PLAIN"
    if [[ "$proto" == "tcp" && "$state" == "LISTEN" ]]; then tag="TCP"; color="$GREEN"
    elif [[ "$proto" == "udp" && "$state" == "UNCONN" ]]; then tag="UDP"; color="$BLUE"
    else continue
    fi

    local port
    port="$(echo "$localaddr" | awk -F':' '{print $NF}')"
    is_number "$port" || continue

    local pname
    pname="$(echo "$process" | awk -F'"' '{print $2}')"
    [[ -z "$pname" ]] && pname="-"

    plist[$idx]="$port"
    proto_list[$idx]="$proto"
    printf "${color}[%d]${PLAIN}  %-6s %-8s %-20s\n" "$idx" "$tag" "$port" "$pname"
    idx=$((idx+1))
  done < <(ss -H -tunlp 2>/dev/null | awk '{print $1, $2, $5, $6, $7}')

  echo -e "------------------------------------------------"
  echo -e "${GREEN}[m]${PLAIN} 手动输入端口"
  echo -e "------------------------------------------------"
  read -p "请选择编号(或 m): " sel

  if [[ "$sel" == "m" ]]; then
    read -p "请输入端口号: " p
    if ! is_number "$p" || [[ "$p" -le 0 || "$p" -gt 65535 ]]; then
      echo -e "${RED}端口无效${PLAIN}"
      SELECTED_PORT=""
      return
    fi
    SELECTED_PORT="$p"
  else
    if [[ -n "${plist[$sel]:-}" ]]; then
      SELECTED_PORT="${plist[$sel]}"
      echo -e "${BLUE}你选择了端口: ${SELECTED_PORT} (${proto_list[$sel]^^})${PLAIN}"
    else
      echo -e "${RED}无效选择${PLAIN}"
      SELECTED_PORT=""
    fi
  fi
}

menu_list_ports(){
  clear
  echo -e "${BLUE}--- 监听端口列表（TCP/UDP，支持编号点选）---${PLAIN}"
  select_active_port || true
}

# ==================================================
# 2) Xray total limit
# ==================================================
detect_xray_uid(){
  local uid=""
  uid="$(ps -eo comm,uid 2>/dev/null | awk '$1=="xray"{print $2; exit}')"
  [[ -z "$uid" ]] && uid="$(ps -eo comm,uid 2>/dev/null | awk '$1 ~ /^xray/ {print $2; exit}')"
  [[ -z "$uid" ]] && { id -u xray >/dev/null 2>&1 && uid="$(id -u xray)"; }
  echo "$uid"
}

get_xray_listen_ports(){
  ss -H -tunlp 2>/dev/null | awk '$0 ~ /xray/ {print $1, $2, $5}' | while read -r proto state addr; do
    if [[ "$proto" == "tcp" && "$state" != "LISTEN" ]]; then continue; fi
    if [[ "$proto" == "udp" && "$state" != "UNCONN" ]]; then continue; fi
    port="$(echo "$addr" | awk -F':' '{print $NF}')"
    [[ "$port" =~ ^[0-9]+$ ]] && echo "$port"
  done | sort -n | uniq
}

ensure_nft_mark_rule(){
  local uid="$1"
  if ! has_nft; then
    echo -e "${RED}[FAIL]${PLAIN} 未安装 nftables。建议：apt install -y nftables"
    return 1
  fi

  nft list table inet "$NFT_TABLE" >/dev/null 2>&1 || nft add table inet "$NFT_TABLE" >/dev/null 2>&1 || true
  if ! nft list chain inet "$NFT_TABLE" "$NFT_CHAIN" >/dev/null 2>&1; then
    nft add chain inet "$NFT_TABLE" "$NFT_CHAIN" "{ type filter hook output priority mangle; policy accept; }" >/dev/null 2>&1 || true
  fi

  if nft list chain inet "$NFT_TABLE" "$NFT_CHAIN" 2>/dev/null | grep -q "meta skuid .* meta mark set ${XRAY_MARK_DEC}"; then
    return 0
  fi

  run_or_fail "nft 添加 xray mark 规则失败（可能内核不支持 meta skuid）" \
    nft add rule inet "$NFT_TABLE" "$NFT_CHAIN" meta skuid "$uid" meta mark set "$XRAY_MARK_DEC" || return 1
  return 0
}

apply_xray_out_limit(){
  local mbps="$1"
  local uid; uid="$(detect_xray_uid)"
  [[ -z "$uid" ]] && { echo -e "${RED}[FAIL]${PLAIN} 未找到 xray 进程/用户"; return 1; }

  ensure_nft_mark_rule "$uid" || return 1

  local rate_kbit=$((mbps * 1000))
  local handle_hex="0200"

  tc filter del dev "$INTERFACE" parent 1:0 protocol all prio 10 >/dev/null 2>&1 || true
  tc qdisc  del dev "$INTERFACE" parent "$XRAY_OUT_CLASSID" >/dev/null 2>&1 || true
  tc class  del dev "$INTERFACE" parent 1:1 classid "$XRAY_OUT_CLASSID" >/dev/null 2>&1 || true

  run_or_fail "创建 xray 出站 class 失败" tc class add dev "$INTERFACE" parent 1:1 classid "$XRAY_OUT_CLASSID" htb \
    rate "${rate_kbit}kbit" ceil "${rate_kbit}kbit" burst "$HTB_BURST" quantum "$USER_QUANTUM" || return 1

  attach_precise_leaf "$INTERFACE" "$XRAY_OUT_CLASSID" "$handle_hex" "$rate_kbit" || return 1

  run_or_fail "添加 fw filter 失败" tc filter add dev "$INTERFACE" parent 1:0 protocol all prio 10 \
    handle "$XRAY_MARK_DEC" fw flowid "$XRAY_OUT_CLASSID" || return 1

  db_upsert "XRAY" "OUT" "out" "$mbps" "class=200"
  echo -e "${GREEN}[Success]${PLAIN} Xray 总出站限制：${mbps} Mbps"
}

apply_xray_in_limit(){
  local mbps="$1"
  local ports; ports="$(get_xray_listen_ports)"
  [[ -z "$ports" ]] && { echo -e "${RED}[FAIL]${PLAIN} 未检测到 xray 正在监听端口"; return 1; }

  local count; count="$(echo "$ports" | wc -l | tr -d ' ')"
  echo -e "${YELLOW}检测到 Xray 监听端口数：${count}${PLAIN}"
  echo -e "${YELLOW}端口列表：${PLAIN} $(echo "$ports" | tr '\n' ' ')"

  local rate_kbit=$((mbps * 1000))
  local handle_hex="0201"

  tc qdisc del dev "$IFB_DEV" parent "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
  tc class del dev "$IFB_DEV" parent 1:1 classid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true

  run_or_fail "创建 xray 入站 class 失败" tc class add dev "$IFB_DEV" parent 1:1 classid "$XRAY_IN_CLASSID" htb \
    rate "${rate_kbit}kbit" ceil "${rate_kbit}kbit" burst "$HTB_BURST" quantum "$USER_QUANTUM" || return 1

  attach_precise_leaf "$IFB_DEV" "$XRAY_IN_CLASSID" "$handle_hex" "$rate_kbit" || return 1

  while read -r p; do
    [[ -z "$p" ]] && continue

    tc filter del dev "$IFB_DEV" parent 1:0 protocol ip prio "$p" >/dev/null 2>&1 || true
    tc filter add dev "$IFB_DEV" parent 1:0 protocol ip prio "$p" u32 \
      match ip dport "$p" 0xffff flowid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true

    tc filter del dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$p" >/dev/null 2>&1 || true
    if has_flower; then
      tc filter add dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$p" flower ip_proto tcp dst_port "$p" flowid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
      tc filter add dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$p" flower ip_proto udp dst_port "$p" flowid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
    fi
  done <<< "$ports"

  if ! has_flower; then
    echo -e "${YELLOW}提示：flower 不可用时，IPv6 入站端口匹配可能不完整（IPv6 可能绕过）。${PLAIN}"
  fi

  db_upsert "XRAY" "IN" "in" "$mbps" "class=201"
  echo -e "${GREEN}[Success]${PLAIN} Xray 总入站限制：${mbps} Mbps"
}

menu_set_xray_limits(){
  echo -e "\n${BLUE}--- 限制 Xray 总出站/总入站速度（可分开设置）---${PLAIN}"
  echo -e "1) 仅限制 出站"
  echo -e "2) 仅限制 入站"
  echo -e "3) 同时限制 入站+出站"
  read -p "选择[1-3]: " sel

  read -p "请输入速率(Mbps): " mbps
  if ! is_number "$mbps" || [[ "$mbps" -le 0 ]]; then
    echo -e "${RED}错误：速率必须为正整数 Mbps${PLAIN}"
    return
  fi

  init_all || { echo -e "${RED}[FAIL]${PLAIN} 初始化 tc/ifb 失败"; return; }

  case "$sel" in
    1) apply_xray_out_limit "$mbps" ;;
    2) apply_xray_in_limit "$mbps" ;;
    3) apply_xray_out_limit "$mbps" && apply_xray_in_limit "$mbps" ;;
    *) echo -e "${YELLOW}无效选择${PLAIN}" ;;
  esac
}

# ==================================================
# 3) Per-port shaping (split in/out)
# ==================================================
apply_port_limit_one(){
  local port="$1" dir="$2" mbps="$3"
  local rate_kbit=$((mbps * 1000))

  local minor_hex
  minor_hex="$(alloc_minor_for_port "$port")"
  if [[ -z "$minor_hex" ]]; then
    echo -e "${RED}[FAIL]${PLAIN} 无法为端口 ${port} 分配 classid（minor 池耗尽）"
    return 1
  fi

  local classid="1:${minor_hex}"
  local handle_hex="$minor_hex"

  if [[ "$dir" == "out" ]]; then
    tc filter del dev "$INTERFACE" parent 1:0 protocol ip prio "$port" >/dev/null 2>&1 || true
    tc filter del dev "$INTERFACE" parent 1:0 protocol ipv6 prio "$port" >/dev/null 2>&1 || true
    tc class del dev "$INTERFACE" parent 1:1 classid "$classid" >/dev/null 2>&1 || true

    run_or_fail "创建端口出站 class 失败" tc class add dev "$INTERFACE" parent 1:1 classid "$classid" htb \
      rate "${rate_kbit}kbit" ceil "${rate_kbit}kbit" burst "$HTB_BURST" quantum "$USER_QUANTUM" || return 1

    attach_precise_leaf "$INTERFACE" "$classid" "$handle_hex" "$rate_kbit" || return 1

    run_or_fail "添加 IPv4 出站 sport(TCP) 失败" tc filter add dev "$INTERFACE" parent 1:0 protocol ip prio "$port" u32 \
      match ip protocol 6 0xff match ip sport "$port" 0xffff flowid "$classid" || return 1
    tc filter add dev "$INTERFACE" parent 1:0 protocol ip prio "$port" u32 \
      match ip protocol 17 0xff match ip sport "$port" 0xffff flowid "$classid" >/dev/null 2>&1 || true

    if has_flower; then
      tc filter add dev "$INTERFACE" parent 1:0 protocol ipv6 prio "$port" flower ip_proto tcp src_port "$port" flowid "$classid" >/dev/null 2>&1 || true
      tc filter add dev "$INTERFACE" parent 1:0 protocol ipv6 prio "$port" flower ip_proto udp src_port "$port" flowid "$classid" >/dev/null 2>&1 || true
    else
      echo -e "${YELLOW}提示：flower 不可用时，IPv6 出站端口匹配可能绕过。${PLAIN}"
    fi

    db_upsert "PORT" "$port" "out" "$mbps" "minor=${minor_hex}"
    echo -e "${GREEN}[Success]${PLAIN} 端口 ${port} 出站限制：${mbps} Mbps (class ${classid})"
    return 0
  fi

  if [[ "$dir" == "in" ]]; then
    tc filter del dev "$IFB_DEV" parent 1:0 protocol ip prio "$port" >/dev/null 2>&1 || true
    tc filter del dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$port" >/dev/null 2>&1 || true
    tc class del dev "$IFB_DEV" parent 1:1 classid "$classid" >/dev/null 2>&1 || true

    run_or_fail "创建端口入站 class 失败" tc class add dev "$IFB_DEV" parent 1:1 classid "$classid" htb \
      rate "${rate_kbit}kbit" ceil "${rate_kbit}kbit" burst "$HTB_BURST" quantum "$USER_QUANTUM" || return 1

    attach_precise_leaf "$IFB_DEV" "$classid" "$handle_hex" "$rate_kbit" || return 1

    run_or_fail "添加 IPv4 入站 dport 失败" tc filter add dev "$IFB_DEV" parent 1:0 protocol ip prio "$port" u32 \
      match ip dport "$port" 0xffff flowid "$classid" || return 1

    if has_flower; then
      tc filter add dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$port" flower ip_proto tcp dst_port "$port" flowid "$classid" >/dev/null 2>&1 || true
      tc filter add dev "$IFB_DEV" parent 1:0 protocol ipv6 prio "$port" flower ip_proto udp dst_port "$port" flowid "$classid" >/dev/null 2>&1 || true
    else
      echo -e "${YELLOW}提示：flower 不可用时，IPv6 入站端口匹配可能绕过。${PLAIN}"
    fi

    db_upsert "PORT" "$port" "in" "$mbps" "minor=${minor_hex}"
    echo -e "${GREEN}[Success]${PLAIN} 端口 ${port} 入站限制：${mbps} Mbps (class ${classid})"
    return 0
  fi

  return 1
}

menu_port_limit(){
  echo -e "\n${BLUE}--- 限制特定端口速率（上下行可分开设置）---${PLAIN}"
  select_active_port
  [[ -z "$SELECTED_PORT" ]] && return
  local port="$SELECTED_PORT"

  echo -e "\n选择方向："
  echo -e "1) 仅限制 ${GREEN}出站/下行${PLAIN}"
  echo -e "2) 仅限制 ${GREEN}入站/上行${PLAIN}"
  echo -e "3) 同时限制 ${YELLOW}入站+出站${PLAIN}"
  read -p "选择[1-3]: " sel

  read -p "请输入速率(Mbps): " mbps
  if ! is_number "$mbps" || [[ "$mbps" -le 0 ]]; then
    echo -e "${RED}错误：速率必须为正整数 Mbps${PLAIN}"
    return
  fi

  init_all || { echo -e "${RED}[FAIL]${PLAIN} 初始化 tc/ifb 失败"; return; }

  case "$sel" in
    1) apply_port_limit_one "$port" "out" "$mbps" ;;
    2) apply_port_limit_one "$port" "in"  "$mbps" ;;
    3) apply_port_limit_one "$port" "out" "$mbps" && apply_port_limit_one "$port" "in" "$mbps" ;;
    *) echo -e "${YELLOW}无效选择${PLAIN}" ;;
  esac
}

# ==================================================
# 4) Show limits
# ==================================================
show_limits(){
  clear
  echo -e "${BLUE}--- 当前限速清单（可靠记录）---${PLAIN}"
  echo -e "网卡: ${GREEN}${INTERFACE}${PLAIN} | IFB: ${GREEN}${IFB_DEV}${PLAIN} | flower: $(has_flower && echo -e "${GREEN}OK${PLAIN}" || echo -e "${YELLOW}NO(IPv6可能绕过)${PLAIN}")"
  echo -e "--------------------------------------------------------------------------------"
  printf "%-8s %-8s %-6s %-8s %-20s %-12s\n" "类型" "对象" "方向" "速率" "时间" "附加"
  echo -e "--------------------------------------------------------------------------------"

  if [[ ! -s "$DB_FILE" ]]; then
    echo -e "${YELLOW}(清单为空)${PLAIN}"
    return
  fi

  while IFS='|' read -r type key dir mbps ts meta; do
    printf "%-8s %-8s %-6s %-8s %-20s %-12s\n" "$type" "$key" "$dir" "${mbps}M" "$ts" "$meta"
  done < "$DB_FILE"

  echo -e "--------------------------------------------------------------------------------"
}

# ==================================================
# 5) Remove Xray limits
# ==================================================
remove_xray_out_limit(){
  tc filter del dev "$INTERFACE" parent 1:0 protocol all prio 10 >/dev/null 2>&1 || true
  tc qdisc  del dev "$INTERFACE" parent "$XRAY_OUT_CLASSID" >/dev/null 2>&1 || true
  tc class  del dev "$INTERFACE" parent 1:1 classid "$XRAY_OUT_CLASSID" >/dev/null 2>&1 || true
  if has_nft; then nft delete table inet "$NFT_TABLE" >/dev/null 2>&1 || true; fi
  db_delete_prefix "XRAY" "OUT"
  echo -e "${GREEN}已移除 Xray 总出站限速（并清理 nft 标记）${PLAIN}"
}

remove_xray_in_limit(){
  tc qdisc del dev "$IFB_DEV" parent "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
  tc class del dev "$IFB_DEV" parent 1:1 classid "$XRAY_IN_CLASSID" >/dev/null 2>&1 || true
  db_delete_prefix "XRAY" "IN"
  echo -e "${GREEN}已移除 Xray 总入站限速（IFB class 清理）${PLAIN}"
  echo -e "${YELLOW}提示：若你多次设置过入站限速，可能残留端口 filter；可用“全部重置”一键清理。${PLAIN}"
}

menu_remove_xray_limits(){
  echo -e "\n${BLUE}--- 移除 Xray 限速（入站/出站）---${PLAIN}"
  echo -e "1) 仅移除 出站"
  echo -e "2) 仅移除 入站"
  echo -e "3) 移除 入站+出站"
  read -p "选择[1-3]: " sel
  init_all >/dev/null 2>&1 || true
  case "$sel" in
    1) remove_xray_out_limit ;;
    2) remove_xray_in_limit ;;
    3) remove_xray_out_limit; remove_xray_in_limit ;;
    *) echo -e "${YELLOW}无效选择${PLAIN}" ;;
  esac
}

# ==================================================
# 6) Reset all
# ==================================================
reset_all(){
  tc qdisc del dev "$INTERFACE" root >/dev/null 2>&1 || true
  tc qdisc del dev "$INTERFACE" ingress >/dev/null 2>&1 || true
  tc qdisc del dev "$IFB_DEV" root >/dev/null 2>&1 || true
  ip link set dev "$IFB_DEV" down >/dev/null 2>&1 || true
  ip link del dev "$IFB_DEV" >/dev/null 2>&1 || true
  if has_nft; then nft delete table inet "$NFT_TABLE" >/dev/null 2>&1 || true; fi
  : > "$DB_FILE" 2>/dev/null || true
  echo -e "${GREEN}已全部重置：tc/IFB/nft/清单 全部清理完成${PLAIN}"
}

# ==================================================
# 7) Speedtest UI-like (fixed 500MB, progress)
# ==================================================
calc_mbps(){
  local bytes="$1" sec="$2"
  awk -v b="$bytes" -v s="$sec" 'BEGIN{ if(s<=0){print "0"; exit} printf "%.2f", (b*8/1000000)/s }'
}

speedtest_fixed_500mb(){
  echo -e "\n${BLUE}--- Speedtest（固定 500MB，上下行分开，“测速UI”风格进度）---${PLAIN}"
  read -p "测试主机(默认 speed.cloudflare.com): " host
  [[ -z "$host" ]] && host="speed.cloudflare.com"

  read -p "测试端口(默认 443，可填 80/443/其他): " port
  [[ -z "$port" ]] && port="443"
  if ! is_number "$port"; then
    echo -e "${RED}端口必须是数字${PLAIN}"
    return
  fi

  local scheme="https"
  [[ "$port" == "80" ]] && scheme="http"

  local down_url="${scheme}://${host}:${port}/__down?bytes=${SPEEDTEST_BYTES}"
  local up_url="${scheme}://${host}:${port}/__up"

  local dtmp utmp
  dtmp="$(mktemp /tmp/vps-tc-dl.XXXXXX)"
  utmp="$(mktemp /tmp/vps-tc-ul.XXXXXX)"

  echo -e "${YELLOW}下载测试中...${PLAIN} (${SPEEDTEST_MB}MB via ${host}:${port})"
  # UI-like：用 --progress-bar（比 -# 信息更完整），进度走 stderr（必须保留）
  curl --progress-bar -o /dev/null --connect-timeout 8 --max-time 600 -w "%{time_total}" "$down_url" >"$dtmp"
  local dtime; dtime="$(cat "$dtmp" 2>/dev/null)"
  rm -f "$dtmp" >/dev/null 2>&1 || true
  local dMbps; dMbps="$(calc_mbps "$SPEEDTEST_BYTES" "$dtime")"
  echo -e "${GREEN}Download:${PLAIN} ${dMbps} Mbps  (耗时 ${dtime}s)"

  echo -e "${YELLOW}上传测试中...${PLAIN} (${SPEEDTEST_MB}MB via ${host}:${port})"
  head -c "$SPEEDTEST_BYTES" </dev/zero | \
    curl --progress-bar -o /dev/null --connect-timeout 8 --max-time 600 -w "%{time_total}" \
      -X POST --data-binary @- "$up_url" >"$utmp"
  local utime; utime="$(cat "$utmp" 2>/dev/null)"
  rm -f "$utmp" >/dev/null 2>&1 || true
  local uMbps; uMbps="$(calc_mbps "$SPEEDTEST_BYTES" "$utime")"
  echo -e "${GREEN}Upload:${PLAIN}   ${uMbps} Mbps  (耗时 ${utime}s)"
}

# ==================================================
# Menu
# ==================================================
show_menu(){
  clear
  echo -e "=================================================="
  echo -e "   VPS 流量控制台 V10.4（端口限速+测速UI进度）"
  echo -e "   网卡: ${GREEN}${INTERFACE}${PLAIN} | IFB: ${GREEN}${IFB_DEV}${PLAIN}"
  echo -e "   nftables: $(has_nft && echo -e "${GREEN}OK${PLAIN}" || echo -e "${YELLOW}缺失(建议安装)${PLAIN}")"
  echo -e "=================================================="
  echo -e "1. 监听目前所有端口 (TCP/UDP，支持编号点选)"
  echo -e "2. 限制 Xray 总出站/总入站速度（可分开设置）"
  echo -e "3. 限制 特定端口 速率（上下行可分开设置）"
  echo -e "4. 查看当前所有端口/项目的限速情况（清单）"
  echo -e "5. 移除 Xray 的限速（入站/出站）"
  echo -e "6. 全部重置（恢复脚本修改的所有项目）"
  echo -e "7. Speedtest 测速（指定端口；固定 500MB；上下行分开；进度条）"
  echo -e "0. 退出"
  echo -e "=================================================="
  read -p "选择: " c

  case "$c" in
    1) menu_list_ports; read -p "回车返回..." ;;
    2) menu_set_xray_limits; read -p "回车返回..." ;;
    3) menu_port_limit; read -p "回车返回..." ;;
    4) show_limits; read -p "回车返回..." ;;
    5) menu_remove_xray_limits; read -p "回车返回..." ;;
    6) reset_all; read -p "回车返回..." ;;
    7) speedtest_fixed_500mb; read -p "回车返回..." ;;
    0) exit 0 ;;
    *) show_menu ;;
  esac
  show_menu
}

show_menu
