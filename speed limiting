#!/bin/bash

# ==================================================
# VPS 流量控制台 V8.3 (Interactive - IFB Shaping, Dual-Stack, Flower Preferred)
# 修复：
# - 有时端口限不住：补齐 IPv6 + 使用 flower 分类器（更稳定）
# - TCP/UDP 全覆盖：同端口对 TCP/UDP 都加规则
# - 入方向不再 police drop：IFB shaping（避免“像断网”）
# ==================================================

RED='\033[31m'
GREEN='\033[32m'
YELLOW='\033[33m'
BLUE='\033[36m'
PLAIN='\033[0m'

[[ $EUID -ne 0 ]] && echo -e "${RED}错误：请使用 root 用户运行！${PLAIN}" && exit 1

for cmd in ip tc ss awk grep printf uname curl tar modprobe; do
  command -v "$cmd" >/dev/null 2>&1 || { echo -e "${RED}缺少命令: $cmd${PLAIN}"; exit 1; }
done

INTERFACE=$(ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}')
[[ -z "$INTERFACE" ]] && echo -e "${RED}错误：无法自动识别网卡，请检查路由/网络。${PLAIN}" && exit 1

IFB_DEV="ifb0"

USER_QUANTUM=15000
ROOT_QUANTUM=200000

DEFAULT_MINOR_HEX="fffe"
DEFAULT_CLASSID="1:${DEFAULT_MINOR_HEX}"
DEFAULT_HANDLE="fffe:"

PORT_CLASS_OFFSET=4096
ROOT_RATE="10000mbit"
DEFAULT_BURST="1m"

SELECTED_PORT=""

# ----------------- utils -----------------
is_number() { [[ "$1" =~ ^[0-9]+$ ]]; }

port_to_hex_minor() {
  local port="$1"
  local minor=$((port + PORT_CLASS_OFFSET))
  printf '%x' "$minor"
}

has_flower() {
  # flower 是内核模块/功能，不好“查询”，用一次无害的命令探测最靠谱
  # 这里只做轻量判断：tc help 里通常会出现 flower（不同版本不一定）
  tc filter help 2>/dev/null | grep -qi flower
}

# 统一：幂等地创建 HTB 树 + 默认类 fq_codel
init_htb_tree() {
  local dev="$1"

  if ! tc qdisc show dev "$dev" 2>/dev/null | grep -q "htb 1:"; then
    tc qdisc add dev "$dev" root handle 1: htb default "$DEFAULT_MINOR_HEX" r2q 10 2>/dev/null || true
  else
    tc qdisc replace dev "$dev" root handle 1: htb default "$DEFAULT_MINOR_HEX" r2q 10 2>/dev/null || true
  fi

  if ! tc class show dev "$dev" 2>/dev/null | grep -q "1:1 "; then
    tc class add dev "$dev" parent 1: classid 1:1 htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" 2>/dev/null || true
  else
    tc class replace dev "$dev" parent 1: classid 1:1 htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" 2>/dev/null || true
  fi

  if ! tc class show dev "$dev" 2>/dev/null | grep -q "${DEFAULT_CLASSID} "; then
    tc class add dev "$dev" parent 1:1 classid "$DEFAULT_CLASSID" htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" 2>/dev/null || true
  else
    tc class replace dev "$dev" parent 1:1 classid "$DEFAULT_CLASSID" htb rate "$ROOT_RATE" quantum "$ROOT_QUANTUM" 2>/dev/null || true
  fi

  tc qdisc replace dev "$dev" parent "$DEFAULT_CLASSID" handle "$DEFAULT_HANDLE" fq_codel 2>/dev/null || true
}

ensure_ifb() {
  modprobe ifb >/dev/null 2>&1 || true

  if ! ip link show "$IFB_DEV" >/dev/null 2>&1; then
    ip link add "$IFB_DEV" type ifb >/dev/null 2>&1 || {
      echo -e "${RED}错误：创建 $IFB_DEV 失败（内核/权限/模块问题）。${PLAIN}"
      return 1
    }
  fi
  ip link set dev "$IFB_DEV" up >/dev/null 2>&1 || true
  return 0
}

ensure_ingress_redirect() {
  ensure_ifb || return 1

  if ! tc qdisc show dev "$INTERFACE" 2>/dev/null | grep -q "ffff:"; then
    tc qdisc add dev "$INTERFACE" handle ffff: ingress 2>/dev/null || true
  fi

  # IPv4 redirect（prio 1）
  if ! tc filter show dev "$INTERFACE" parent ffff: 2>/dev/null | grep -q "protocol ip.*mirred.*redirect.*$IFB_DEV"; then
    tc filter del dev "$INTERFACE" parent ffff: protocol ip prio 1 >/dev/null 2>&1 || true
    tc filter add dev "$INTERFACE" parent ffff: protocol ip prio 1 u32 \
      match u32 0 0 action mirred egress redirect dev "$IFB_DEV" 2>/dev/null || {
        echo -e "${RED}错误：设置 IPv4 ingress redirect 失败。${PLAIN}"
        return 1
      }
  fi

  # IPv6 redirect（prio 2）——这是你之前缺的“绕过点”
  if ! tc filter show dev "$INTERFACE" parent ffff: 2>/dev/null | grep -q "protocol ipv6.*mirred.*redirect.*$IFB_DEV"; then
    tc filter del dev "$INTERFACE" parent ffff: protocol ipv6 prio 2 >/dev/null 2>&1 || true
    tc filter add dev "$INTERFACE" parent ffff: protocol ipv6 prio 2 u32 \
      match u32 0 0 action mirred egress redirect dev "$IFB_DEV" 2>/dev/null || {
        echo -e "${RED}错误：设置 IPv6 ingress redirect 失败。${PLAIN}"
        return 1
      }
  fi

  return 0
}

init_all_trees() {
  init_htb_tree "$INTERFACE"
  ensure_ingress_redirect || return 1
  init_htb_tree "$IFB_DEV"
  return 0
}

# ----- filter helpers -----

# 删除指定 prio 的过滤规则（同时清理 ip/ipv6）
del_prio_filters() {
  local dev="$1"
  local parent="$2"
  local prio="$3"
  tc filter del dev "$dev" parent "$parent" protocol ip   prio "$prio" >/dev/null 2>&1 || true
  tc filter del dev "$dev" parent "$parent" protocol ipv6 prio "$prio" >/dev/null 2>&1 || true
}

# 尝试用 flower 添加分类规则；失败则回退 u32（IPv4 only 回退，IPv6 回退可能不支持端口匹配）
add_classify_filter() {
  local dev="$1"       # device
  local parent="$2"    # parent 1:0
  local proto="$3"     # ip / ipv6
  local prio="$4"      # prio number
  local l4="$5"        # tcp / udp
  local dir="$6"       # out=in sport, in=dport
  local port="$7"      # port number
  local flowid="$8"    # classid like 1:abcd

  # 先删同 prio，避免重复叠加
  tc filter del dev "$dev" parent "$parent" protocol "$proto" prio "$prio" >/dev/null 2>&1 || true

  # flower（更稳定、也能明确区分 tcp/udp）
  # 说明：对于 TCP/UDP 都各加一条，命中率最高
  if has_flower; then
    if [[ "$dir" == "out" ]]; then
      tc filter add dev "$dev" parent "$parent" protocol "$proto" prio "$prio" flower \
        ip_proto "$l4" src_port "$port" flowid "$flowid" 2>/dev/null && return 0
    else
      tc filter add dev "$dev" parent "$parent" protocol "$proto" prio "$prio" flower \
        ip_proto "$l4" dst_port "$port" flowid "$flowid" 2>/dev/null && return 0
    fi
  fi

  # 回退：u32（可靠性次一点，但 IPv4 通常够用）
  if [[ "$proto" == "ip" ]]; then
    if [[ "$dir" == "out" ]]; then
      tc filter add dev "$dev" parent "$parent" protocol ip prio "$prio" u32 \
        match ip protocol 6 0xff match ip sport "$port" 0xffff flowid "$flowid" 2>/dev/null && return 0
      tc filter add dev "$dev" parent "$parent" protocol ip prio "$prio" u32 \
        match ip protocol 17 0xff match ip sport "$port" 0xffff flowid "$flowid" 2>/dev/null && return 0
    else
      tc filter add dev "$dev" parent "$parent" protocol ip prio "$prio" u32 \
        match ip protocol 6 0xff match ip dport "$port" 0xffff flowid "$flowid" 2>/dev/null && return 0
      tc filter add dev "$dev" parent "$parent" protocol ip prio "$prio" u32 \
        match ip protocol 17 0xff match ip dport "$port" 0xffff flowid "$flowid" 2>/dev/null && return 0
    fi
  fi

  return 1
}

# ----------------- port picker (TCP/UDP) -----------------
function select_active_port() {
  echo -e "${YELLOW}[List] 正在扫描可操作端口(TCP/UDP)...${PLAIN}"
  echo -e "------------------------------------------------"
  printf "%-5s %-10s %-12s %-20s\n" "编号" "协议" "端口" "进程"
  echo -e "------------------------------------------------"

  declare -a port_list
  declare -a proto_list
  index=1

  while read -r proto state localaddr _peer process; do
    if [[ "$proto" == "tcp" ]]; then
      [[ "$state" != "LISTEN" ]] && continue
      show_proto="TCP"; pcolor="${GREEN}"
    elif [[ "$proto" == "udp" ]]; then
      [[ "$state" != "UNCONN" ]] && continue
      show_proto="UDP"; pcolor="${BLUE}"
    else
      continue
    fi

    port=$(echo "$localaddr" | awk -F':' '{print $NF}')
    is_number "$port" || continue

    proc_name=$(echo "$process" | awk -F'"' '{print $2}')
    [[ -z "$proc_name" ]] && proc_name="-"

    port_list[$index]="$port"
    proto_list[$index]="$proto"
    printf "${pcolor}[%d]${PLAIN}   %-10s %-12s %-20s\n" "$index" "$show_proto" "$port" "$proc_name"
    ((index++))
  done < <(ss -H -tunlp 2>/dev/null | awk '{print $1, $2, $5, $6, $7}')

  echo -e "------------------------------------------------"
  echo -e "${GREEN}[m]${PLAIN}   手动输入端口号 (Manual Input)"
  echo -e "------------------------------------------------"

  read -p "请选择端口编号 (输入 m 手动填写): " select_idx

  if [[ "$select_idx" == "m" ]]; then
    read -p "请输入端口号: " input_port
    if ! is_number "$input_port"; then
      echo -e "${RED}错误：端口必须是数字！${PLAIN}"
      SELECTED_PORT=""
      return
    fi
    SELECTED_PORT="$input_port"
  elif [[ -n "${port_list[$select_idx]}" ]]; then
    SELECTED_PORT="${port_list[$select_idx]}"
    echo -e "${BLUE}你选择了端口: $SELECTED_PORT (${proto_list[$select_idx]^^})${PLAIN}"
  else
    echo -e "${RED}无效选择！${PLAIN}"
    SELECTED_PORT=""
  fi
}

# ----------------- status (TCP/UDP) -----------------
function check_port_status() {
  clear
  echo -e "${YELLOW}[Scanning] 活跃端口深度扫描(TCP/UDP)...${PLAIN}"
  echo -e "----------------------------------------------------------------------"
  printf "%-10s %-12s %-15s %-15s %-20s\n" "协议" "端口" "状态" "活跃连接数" "进程名"
  echo -e "----------------------------------------------------------------------"

  while read -r proto state localaddr _peer process; do
    if [[ "$proto" == "tcp" ]]; then
      [[ "$state" != "LISTEN" ]] && continue
      ptag="TCP"; pcolor="${GREEN}"
      port=$(echo "$localaddr" | awk -F':' '{print $NF}'); is_number "$port" || continue
      conn=$(ss -H -tn state established 2>/dev/null | awk '{print $4}' | grep -w ":$port" | wc -l)
    elif [[ "$proto" == "udp" ]]; then
      [[ "$state" != "UNCONN" ]] && continue
      ptag="UDP"; pcolor="${BLUE}"
      port=$(echo "$localaddr" | awk -F':' '{print $NF}'); is_number "$port" || continue
      conn=$(ss -H -un 2>/dev/null | awk '{print $5,$6}' | awk -v p=":$port" '$1 ~ p && $2 !~ /\*:\*/ {c++} END{print c+0}')
    else
      continue
    fi

    proc=$(echo "$process" | awk -F'"' '{print $2}'); [[ -z "$proc" ]] && proc="-"
    if [[ "$conn" -gt 0 ]]; then conn_str="${conn} (Active)"; conn_color="${RED}"; else conn_str="0"; conn_color="${PLAIN}"; fi

    printf "${pcolor}%-10s${PLAIN} %-12s %-15s ${conn_color}%-15s${PLAIN} %-20s\n" \
      "$ptag" "$port" "Listening" "$conn_str" "$proc"
  done < <(ss -H -tunlp 2>/dev/null | awk '{print $1, $2, $5, $6, $7}')

  echo -e "----------------------------------------------------------------------"
}

# ----------------- apply port limit (dual-stack, tcp+udp) -----------------
function apply_port_limit() {
  echo -e "\n${BLUE}--- 配置端口限速（V8.3 Dual-Stack + Flower）---${PLAIN}"

  select_active_port
  [[ -z "$SELECTED_PORT" ]] && return
  PORT=$SELECTED_PORT

  echo -e "\n请选择限制方向："
  echo -e "1. ${GREEN}下行${PLAIN} (Outbound / 用户下载：物理网卡 egress)"
  echo -e "2. ${GREEN}上行${PLAIN} (Inbound / 用户上传：IFB 入方向整形)"
  echo -e "3. ${YELLOW}双向${PLAIN} (同时限制)"
  read -p "请输入选项 [1-3]: " dir_choice

  case $dir_choice in
    1) direction="out" ;;
    2) direction="in" ;;
    3) direction="bi" ;;
    *) echo -e "${RED}无效选项：默认双向${PLAIN}"; direction="bi" ;;
  esac

  read -p "请输入速率限制 (Mbps): " RATE_MBPS
  if ! is_number "$RATE_MBPS" || [[ "$RATE_MBPS" -le 0 ]]; then
    echo -e "${RED}错误：速率必须为正整数 Mbps${PLAIN}"
    return
  fi

  RATE_KBIT=$((RATE_MBPS * 1000))
  BURST="$DEFAULT_BURST"

  HEX_ID=$(port_to_hex_minor "$PORT")
  CLASSID="1:${HEX_ID}"
  HANDLE="${HEX_ID}0:"

  init_all_trees || { echo -e "${RED}初始化失败：IFB/redirect/HTB 未就绪。${PLAIN}"; return; }

  echo -e "${YELLOW}[Config] Port: $PORT  Rate: ${RATE_MBPS}Mbps  Class: $CLASSID${PLAIN}"

  # --- Outbound (INTERFACE egress): src_port ---
  if [[ "$direction" == "out" || "$direction" == "bi" ]]; then
    del_prio_filters "$INTERFACE" "1:0" "$PORT"
    tc qdisc del dev "$INTERFACE" parent "$CLASSID" >/dev/null 2>&1 || true
    tc class del dev "$INTERFACE" parent 1:1 classid "$CLASSID" >/dev/null 2>&1 || true

    tc class add dev "$INTERFACE" parent 1:1 classid "$CLASSID" htb \
      rate "${RATE_KBIT}kbit" ceil "${RATE_KBIT}kbit" burst "$BURST" quantum "$USER_QUANTUM" 2>/dev/null || \
    tc class replace dev "$INTERFACE" parent 1:1 classid "$CLASSID" htb \
      rate "${RATE_KBIT}kbit" ceil "${RATE_KBIT}kbit" burst "$BURST" quantum "$USER_QUANTUM" 2>/dev/null

    tc qdisc replace dev "$INTERFACE" parent "$CLASSID" handle "$HANDLE" fq_codel 2>/dev/null || true

    # IPv4 + IPv6, TCP + UDP
    add_classify_filter "$INTERFACE" "1:0" "ip"   "$PORT" "tcp" "out" "$PORT" "$CLASSID" >/dev/null 2>&1 || true
    add_classify_filter "$INTERFACE" "1:0" "ip"   "$PORT" "udp" "out" "$PORT" "$CLASSID" >/dev/null 2>&1 || true
    add_classify_filter "$INTERFACE" "1:0" "ipv6" "$PORT" "tcp" "out" "$PORT" "$CLASSID" >/dev/null 2>&1 || true
    add_classify_filter "$INTERFACE" "1:0" "ipv6" "$PORT" "udp" "out" "$PORT" "$CLASSID" >/dev/null 2>&1 || true
  fi

  # --- Inbound (IFB egress): dst_port ---
  if [[ "$direction" == "in" || "$direction" == "bi" ]]; then
    del_prio_filters "$IFB_DEV" "1:0" "$PORT"
    tc qdisc del dev "$IFB_DEV" parent "$CLASSID" >/dev/null 2>&1 || true
    tc class del dev "$IFB_DEV" parent 1:1 classid "$CLASSID" >/dev/null 2>&1 || true

    tc class add dev "$IFB_DEV" parent 1:1 classid "$CLASSID" htb \
      rate "${RATE_KBIT}kbit" ceil "${RATE_KBIT}kbit" burst "$BURST" quantum "$USER_QUANTUM" 2>/dev/null || \
    tc class replace dev "$IFB_DEV" parent 1:1 classid "$CLASSID" htb \
      rate "${RATE_KBIT}kbit" ceil "${RATE_KBIT}kbit" burst "$BURST" quantum "$USER_QUANTUM" 2>/dev/null

    tc qdisc replace dev "$IFB_DEV" parent "$CLASSID" handle "$HANDLE" fq_codel 2>/dev/null || true

    # IPv4 + IPv6, TCP + UDP
    add_classify_filter "$IFB_DEV" "1:0" "ip"   "$PORT" "tcp" "in" "$PORT" "$CLASSID" >/dev/null 2>&1 || true
    add_classify_filter "$IFB_DEV" "1:0" "ip"   "$PORT" "udp" "in" "$PORT" "$CLASSID" >/dev/null 2>&1 || true
    add_classify_filter "$IFB_DEV" "1:0" "ipv6" "$PORT" "tcp" "in" "$PORT" "$CLASSID" >/dev/null 2>&1 || true
    add_classify_filter "$IFB_DEV" "1:0" "ipv6" "$PORT" "udp" "in" "$PORT" "$CLASSID" >/dev/null 2>&1 || true
  fi

  echo -e "${GREEN}[Success] 端口 $PORT 限速已生效（双栈 + TCP/UDP + flower 优先）。${PLAIN}"
}

# ----------------- global limit (dual shaping) -----------------
function apply_global_limit() {
  echo -e "\n${BLUE}--- 全局限速 (整机，出入均 shaping) ---${PLAIN}"
  read -p "请输入总速率 (Mbps): " RATE_MBPS
  if ! is_number "$RATE_MBPS" || [[ "$RATE_MBPS" -le 0 ]]; then
    echo -e "${RED}错误：速率必须为正整数 Mbps${PLAIN}"
    return
  fi

  RATE_KBIT=$((RATE_MBPS * 1000))
  BURST="$DEFAULT_BURST"

  init_all_trees || { echo -e "${RED}初始化失败：IFB/redirect/HTB 未就绪。${PLAIN}"; return; }

  tc class replace dev "$INTERFACE" parent 1:1 classid "$DEFAULT_CLASSID" htb \
    rate "${RATE_KBIT}kbit" ceil "${RATE_KBIT}kbit" burst "$BURST" quantum "$USER_QUANTUM" 2>/dev/null || true
  tc qdisc replace dev "$INTERFACE" parent "$DEFAULT_CLASSID" handle "$DEFAULT_HANDLE" fq_codel 2>/dev/null || true

  tc class replace dev "$IFB_DEV" parent 1:1 classid "$DEFAULT_CLASSID" htb \
    rate "${RATE_KBIT}kbit" ceil "${RATE_KBIT}kbit" burst "$BURST" quantum "$USER_QUANTUM" 2>/dev/null || true
  tc qdisc replace dev "$IFB_DEV" parent "$DEFAULT_CLASSID" handle "$DEFAULT_HANDLE" fq_codel 2>/dev/null || true

  echo -e "${GREEN}[Success] 全局限速已生效（出入均 shaping）。${PLAIN}"
}

# ----------------- remove -----------------
function remove_limit() {
  echo -e "\n1. 解除指定端口 (可区分方向)"
  echo -e "2. 重置所有限制 (网卡级 + IFB + redirect 清理)"
  read -p "选择: " sel

  if [[ "$sel" == "1" ]]; then
    select_active_port
    [[ -z "$SELECTED_PORT" ]] && return
    PORT=$SELECTED_PORT

    HEX_ID=$(port_to_hex_minor "$PORT")
    CLASSID="1:${HEX_ID}"

    echo -e "\n请选择要解除的方向："
    echo -e "1. 仅解除 ${GREEN}下行限制${PLAIN} (Outbound, 物理网卡)"
    echo -e "2. 仅解除 ${GREEN}上行限制${PLAIN} (Inbound, IFB)"
    echo -e "3. 解除 ${RED}双向限制${PLAIN} (Both)"
    read -p "输入选项 [1-3]: " rm_choice

    init_all_trees >/dev/null 2>&1 || true

    case $rm_choice in
      1)
        del_prio_filters "$INTERFACE" "1:0" "$PORT"
        tc qdisc del dev "$INTERFACE" parent "$CLASSID" >/dev/null 2>&1 || true
        tc class del dev "$INTERFACE" parent 1:1 classid "$CLASSID" >/dev/null 2>&1 || true
        echo -e "${GREEN}端口 $PORT [下行] 限制已移除。${PLAIN}"
        ;;
      2)
        del_prio_filters "$IFB_DEV" "1:0" "$PORT"
        tc qdisc del dev "$IFB_DEV" parent "$CLASSID" >/dev/null 2>&1 || true
        tc class del dev "$IFB_DEV" parent 1:1 classid "$CLASSID" >/dev/null 2>&1 || true
        echo -e "${GREEN}端口 $PORT [上行] 限制已移除。${PLAIN}"
        ;;
      *)
        del_prio_filters "$INTERFACE" "1:0" "$PORT"
        tc qdisc del dev "$INTERFACE" parent "$CLASSID" >/dev/null 2>&1 || true
        tc class del dev "$INTERFACE" parent 1:1 classid "$CLASSID" >/dev/null 2>&1 || true

        del_prio_filters "$IFB_DEV" "1:0" "$PORT"
        tc qdisc del dev "$IFB_DEV" parent "$CLASSID" >/dev/null 2>&1 || true
        tc class del dev "$IFB_DEV" parent 1:1 classid "$CLASSID" >/dev/null 2>&1 || true

        echo -e "${GREEN}端口 $PORT [双向] 限制已全部移除。${PLAIN}"
        ;;
    esac

    init_all_trees >/dev/null 2>&1 || true

  elif [[ "$sel" == "2" ]]; then
    tc qdisc del dev "$INTERFACE" root >/dev/null 2>&1 || true

    tc filter del dev "$INTERFACE" parent ffff: protocol ip   prio 1 >/dev/null 2>&1 || true
    tc filter del dev "$INTERFACE" parent ffff: protocol ipv6 prio 2 >/dev/null 2>&1 || true
    tc qdisc del dev "$INTERFACE" ingress >/dev/null 2>&1 || true

    tc qdisc del dev "$IFB_DEV" root >/dev/null 2>&1 || true

    ip link set dev "$IFB_DEV" down >/dev/null 2>&1 || true
    ip link del "$IFB_DEV" >/dev/null 2>&1 || true

    echo -e "${GREEN}已重置：物理网卡 + IFB + redirect 全部清理完成。${PLAIN}"
  fi
}

# ----------------- speedtest -----------------
function run_pro_speedtest() {
  echo -e "${YELLOW}[Testing] Speedtest...${PLAIN}"
  if [ ! -f "./speedtest" ]; then
    ARCH=$(uname -m)
    [[ "$ARCH" == "x86_64" ]] && URL="https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-x86_64.tgz"
    [[ "$ARCH" == "aarch64" ]] && URL="https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-aarch64.tgz"
    if [[ -z "$URL" ]]; then
      echo -e "${RED}不支持的架构: $ARCH${PLAIN}"
      return
    fi
    curl -sL "$URL" | tar xz speedtest && chmod +x speedtest
  fi
  ./speedtest --accept-license --accept-gdpr
}

# ----------------- menu -----------------
function show_menu() {
  clear
  echo -e "=================================================="
  echo -e "       VPS 流量控制台 V8.3 (IFB Shaping, Dual-Stack, Flower)"
  echo -e "       物理网卡: ${GREEN}${INTERFACE}${PLAIN}"
  echo -e "       IFB 设备: ${GREEN}${IFB_DEV}${PLAIN}"
  echo -e "       默认类:   ${GREEN}${DEFAULT_CLASSID}${PLAIN}"
  echo -e "=================================================="
  echo -e "1. 查看活跃端口 (状态监控)"
  echo -e "--------------------------------------------------"
  echo -e "2. 设置 ${YELLOW}端口限速${PLAIN} (出入均 shaping，IPv4/IPv6，TCP/UDP)"
  echo -e "3. 设置 ${RED}全局限速${PLAIN} (出入均 shaping)"
  echo -e "--------------------------------------------------"
  echo -e "4. 解除限制 / 重置 (含 IFB 清理)"
  echo -e "5. 运行测速 (Speedtest)"
  echo -e "0. 退出"
  echo -e "=================================================="
  read -p "选择: " choice

  case $choice in
    1) check_port_status; read -p "回车返回..." ;;
    2) apply_port_limit; read -p "回车返回..." ;;
    3) apply_global_limit; read -p "回车返回..." ;;
    4) remove_limit; read -p "回车返回..." ;;
    5) run_pro_speedtest; read -p "回车返回..." ;;
    0) exit 0 ;;
    *) show_menu ;;
  esac
  show_menu
}

show_menu
